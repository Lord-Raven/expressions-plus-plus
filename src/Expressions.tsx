import {
    StageBase,
    StageResponse,
    InitialData,
    Message,
    AspectRatio,
    Speaker,
    Character
} from "@chub-ai/stages-ts";
import {LoadResponse} from "@chub-ai/stages-ts/dist/types/load";
import { Client } from "@gradio/client";
import {ReactElement} from "react";
import Scene from "./Scene.tsx";
import SpeakerButton from "./SpeakerButton.tsx";
import BackgroundButton from "./BackgroundButton.tsx";
import {createTheme, ThemeProvider} from "@mui/material";
import {MessageQueue, MessageQueueHandle} from "./MessageQueue.tsx";
import {FastAverageColor} from "fast-average-color";
import {SpeakerSettingsHandle} from "./SpeakerSettings.tsx";
import NewSpeakerSettings from "./NewSpeakerSettings.tsx";
import ColorThief from "colorthief";
import { Emotion, EMOTION_MAPPING, EMOTION_PROMPTS, EmotionPack } from "./Emotion.tsx";
import { Background, DEFAULT_BORDER_COLOR, DEFAULT_HIGHLIGHT_COLOR, BACKGROUND_ART_PROMPT } from "./Background.tsx";
import BackgroundSettings, { BackgroundSettingsHandle } from "./BackgroundSettings.tsx";
import { generateUUID } from "three/src/math/MathUtils.js";



type ChatStateType = {
    generatedWardrobes:{[key: string]: {[key: string]: EmotionPack}};
    selectedOutfit:{[key: string]: string};
    generatedDescriptions:{[key: string]: string};
    speakerVisible:{[key: string]: boolean};
    selectedBackground: string;
}

type OutfitType = {
    // A name for the outfit
    name: string;
    // Description generated by the AI, used for generating the image
    artPrompt: string;
    // Images for the outfit, keyed by emotion
    images: EmotionPack;
    // Comma-delimitted list of trigger words that will swap to this outfit
    triggerWords: string;
    // Whether this outfit was generated by this stage or managed by a built-in emotion pack
    generated: boolean;
    // Whether this outfit is saved locally or globally
    global: boolean;
}

type WardrobeType = {
    speakerId: string;
    outfits: {[key: string]: OutfitType};
}

type ConfigType = {
    artStyle?: string;
    generateCharacters?: string;
    generateBackgrounds?: string;
    selected?: {[key: string]: string} | null;
    alphaMode?: string;
    useBackgroundDepth?: boolean;
};

type InitStateType = null;

type MessageStateType = {
    speakerEmotion: {[key: string]: string};
    activeSpeaker: string;
};

const darkTheme = createTheme({
    palette: {
        mode: 'dark',
        background: {
            default: '#121212',
            paper: '#1e1e1e',
        },
        text: {
            primary: '#ffffff',
            secondary: '#aaaaaa',
        }
    },
});

const CHARACTER_ART_PROMPT: string = 'plain flat background, standing, full body, head-to-toe';
const CHARACTER_NEGATIVE_PROMPT: string = 'border, ((close-up)), scenery, special effects, scene, dynamic angle, action, cut-off';

export const DEFAULT_OUTFIT_NAME: string = 'Starter Outfit';

// Replace trigger words with less triggering words, so image gen can succeed.
export function substitute(input: string) {
    const synonyms: [string, string][] = [
        ['old-school', 'retro'],
        ['old school', 'retro'],
        ['oldschool', 'retro'],
        ['schoolgirl', 'college girl'],
        ['school girl', 'college girl'],
        ['schoolboy', 'college guy'],
        ['school boy', 'college guy'],
        ['schoolteacher', 'professor'],
        ['school teacher', 'professor'],
        ['school', 'college'],
        ['youngster', 'individual'],
        ['child', 'individual'],
        ['kid', 'individual'],
        ['young', 'youthful']
    ];

    for (const [key, replacement] of synonyms) {
        const regex = new RegExp(key, 'gi');
        input = input.replace(regex, (match) => {
            return match[0] === match[0].toUpperCase()
                ? replacement.charAt(0).toUpperCase() + replacement.slice(1)
                : replacement;
        });
    }

    return input;
}

export class Expressions extends StageBase<InitStateType, ChatStateType, MessageStateType, ConfigType> {

    // Chat state:
    chatState: ChatStateType;

    // Message state:
    messageState: MessageStateType;

    // Saved to storage
    wardrobes: {[key: string]: WardrobeType} = {};
    // This is used for comparison versus storage wardrobes to determine if storage has changed outside this instance of the stage,
    // so that those changes can be reconciled against a potentially modified wardrobes above.
    // Should be set after a successful load/reconciliation.
    backupWardrobes: {[key: string]: WardrobeType} = {};
    
    backgrounds: {[key: string]: Background} = {};
    // Should be set after a successful load/reconciliation.
    backupBackgrounds: {[key: string]: Background} = {};

    // Not saved:
    emotionPipeline: any = null;
    zeroShotPipeline: any = null;
    depthPipeline: any = null;
    generateCharacters: boolean;
    generateBackgrounds: boolean;
    useBackgroundDepth: boolean;
    artStyle: string;
    speakers: {[key: string]: Speaker};
    owns: string[] = []; // List of speakerIds that this client owns (generally themself and their owned characters).
    canEdit: string[] = []; // List of speakerIds that this client can edit (generally themself and any character).
    userId: string; // ID of this client

    readonly fac = new FastAverageColor();
    readonly colorThief = new ColorThief();
    private messageHandle?: MessageQueueHandle;
    private speakerSettingsHandle?: SpeakerSettingsHandle;
    private backgroundSettingsHandle?: BackgroundSettingsHandle;

    constructor(data: InitialData<InitStateType, ChatStateType, MessageStateType, ConfigType>) {
        super(data);
        const {
            characters,
            config,
            messageState,
            chatState,
            users,
            userId
        } = data;

        console.log(config);
        console.log(characters);
        console.log(users);

        this.userId = userId;
        this.owns = [userId];
        this.canEdit = [userId, ...Object.keys(characters)];
        this.speakers = {...characters, ...users};

        // Set states or default them.
        this.messageState = {
            speakerEmotion: messageState?.speakerEmotion ?? {},
            activeSpeaker: messageState?.activeSpeaker ?? ''
        }

        this.chatState = {
            generatedWardrobes: chatState?.generatedWardrobes ?? {},
            selectedOutfit: chatState?.selectedOutfit ?? {},
            generatedDescriptions: chatState?.generatedDescriptions ?? {},
            speakerVisible: chatState?.speakerVisible ?? {},
            selectedBackground: chatState?.selectedBackground ?? ''
        };

        this.generateCharacters = (config?.generateCharacters ?? "True") == "True";
        this.generateBackgrounds = (config?.generateBackgrounds ?? "True") == "True";
        this.useBackgroundDepth = (config?.useBackgroundDepth ?? "True") == "True";
        //this.alphaMode = (config?.alphaMode ?? "False") == "True";
        this.artStyle = config?.artStyle ?? 'Vibrant, visual novel style illustration, clean lines';
    }

    async load(): Promise<Partial<LoadResponse<InitStateType, ChatStateType, MessageStateType>>> {

        try {
            this.emotionPipeline = await Client.connect("ravenok/emotions");
            this.zeroShotPipeline = await Client.connect("ravenok/statosphere-backend");
            this.depthPipeline = await Client.connect("ravenok/Depth-Anything-V2");
        } catch (except: any) {
            console.error(`Error loading pipelines, error: ${except}`);
            return { success: false, error: except }
        }

        // Load backgrounds
        if (this.generateBackgrounds) {
            this.backgrounds = await this.readBackgroundsFromStorage();
            console.log('Loaded backgrounds from storage:');
            console.log(this.backgrounds);
            if (Object.keys(this.backgrounds).length == 0) {
                console.log('No backgrounds found in storage, creating default background.');
                console.log(this.backgrounds);
                console.log(Object.keys(this.backgrounds));
                const background = this.createNewBackground('Default Background');
                this.backgrounds[background.id] = background;
                this.wrapPromise(this.generateBackgroundImage(Object.values(this.speakers)[0], background, ''), `Generating background for ${background.name}.`).then(() => {this.setSelectedBackground(background.id)});
            }
            this.backupBackgrounds = JSON.parse(JSON.stringify(this.backgrounds));
        }

        // Sets background image but also updates depth and other elements of incomplete backgrounds.
        await this.updateBackground();
        
        // Test whether userId has storage access to update canonical character data and update owns accordingly
        for (const speakerId of Object.keys(this.speakers)) {
            if (this.isSpeakerIdCharacterId(speakerId)) {
                try {
                    const response: any = await this.storage.set('dummy', {data: "dummy data"}).forCharacterSensitive(speakerId);
                    console.log(response);
                    if (response.errors) {
                        console.error(`Failed sensitive storage access for ${speakerId}: ${response.errors}`);
                    } else {
                        console.log(`Successfully accessed sensitive storage for ${speakerId}`);
                        this.owns.push(speakerId);
                    }
                } catch (error) {
                    console.error(`Error accessing sensitive storage for ${speakerId}: ${error}`);
                }
            }
        }

        // Load wardrobes from storage API:
        this.wardrobes = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
        console.log('Loaded wardrobes from storage:');
        console.log(this.wardrobes);
        this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));

        // Load expression pack wardrobes:
        for (let charAnonId of Object.keys(this.speakers)) {
            if ('partial_extensions' in this.speakers[charAnonId]) {
                const character: Character = this.speakers[charAnonId] as Character;
                if (character.partial_extensions?.chub?.expressions?.expressions != null) {
                    console.log(`Character ${charAnonId} has an expressions pack.`);
                    // Generate outfit entries for each expressions pack, marked non-generated.
                    if (!this.wardrobes[charAnonId]) {
                        this.wardrobes[charAnonId] = {
                            speakerId: charAnonId,
                            outfits: {}
                        };
                    }
                    for (let expressionPack of Object.values([character.partial_extensions.chub.expressions])) {
                        this.wardrobes[charAnonId].outfits[expressionPack.version] = {
                            images: expressionPack.expressions,
                            name: expressionPack.version,
                            triggerWords: '',
                            artPrompt: '',
                            generated: false,
                            global: false
                        };
                    }
                }
            }
        }

        // Initialize wardrobes for characters with no loaded wardrobes
        
        for (let speakerId of Object.keys(this.speakers)) {
            if (!(speakerId in this.wardrobes) || this.wardrobes[speakerId].outfits == null || Object.keys(this.wardrobes[speakerId].outfits).length === 0) {
                console.log(`Initializing wardrobe for ${speakerId}.`);
                this.wardrobes[speakerId] = {
                    speakerId: speakerId,
                    outfits: {
                        [generateUUID()]: {
                            name: DEFAULT_OUTFIT_NAME,
                            artPrompt: '',
                            images: {},
                            triggerWords: '',
                            generated: true,
                            global: false
                        }
                    }
                } as WardrobeType;
            }

            // Set a selected outfit if none exists.
            console.log(`Checking selectedOutfit for ${speakerId}: ${this.chatState.selectedOutfit[speakerId]}`);
            if (!this.chatState.selectedOutfit[speakerId] || this.chatState.selectedOutfit[speakerId] == '' || !(this.chatState.selectedOutfit[speakerId] in this.wardrobes[speakerId].outfits)) {
                console.log(`Setting selectedOutfit for ${speakerId}.`);
                this.chatState.selectedOutfit[speakerId] = Object.keys(this.wardrobes[speakerId].outfits)[0];
            }
        }

        for (let speaker of Object.values(this.speakers)) {
            if (!(speaker.anonymizedId in this.chatState.speakerVisible)) {
                this.chatState.speakerVisible[speaker.anonymizedId] = !('chatProfile' in speaker);
                //this.singleSpeakerCheck(speaker).then(result => {this.chatState.speakerVisible[speaker.anonymizedId] = result; this.updateChatState()});
            }
        }

        return {
            success: true,
            chatState: this.chatState,
            messageState: this.messageState,
            error: null
        };
    }

    async updateBackground() {
        if (this.generateBackgrounds) {
            await this.updateChatState();
            await this.messenger.updateEnvironment({background: this.getSelectedBackground().backgroundUrl});
        }
    }

    async setState(state: MessageStateType): Promise<void> {
        if (state != null) {
            this.messageState = {
                speakerEmotion: state?.speakerEmotion ?? {},
                activeSpeaker: state?.activeSpeaker ?? ''
            }
        }
    }

    async updateEmotion(speaker: Speaker, content: string) {
        let newEmotion = 'neutral';
        if (this.emotionPipeline != null) {
            try {
                const emotionResult = (await this.emotionPipeline.predict("/predict", {
                    param_0: content,
                }))
                console.log(`Emotion result: `);
                console.log(emotionResult.data[0].confidences);
                newEmotion = emotionResult.data[0].confidences.find((confidence: {label: string, score: number}) => confidence.label != 'neutral' && confidence.score > 0.1)?.label ?? newEmotion;
            } catch (except: any) {
                console.warn(`Error classifying expression, error: ${except}`);
                newEmotion = this.fallbackClassify(content);
            }
        } else {
            newEmotion = this.fallbackClassify(content);
        }
        console.info(`New emotion for ${speaker.name}: ${newEmotion}`);
        this.messageState.speakerEmotion[speaker.anonymizedId] = newEmotion;
        this.messageState.activeSpeaker = speaker.anonymizedId;
        if (!this.wardrobes[speaker.anonymizedId].outfits[this.chatState.selectedOutfit[speaker.anonymizedId]]?.images[EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion]) {
            this.wrapPromise(
                this.generateSpeakerImage(speaker, this.chatState.selectedOutfit[speaker.anonymizedId], EMOTION_MAPPING[newEmotion as Emotion] ?? (newEmotion as Emotion)),
                `Generating ${newEmotion} for ${speaker.name} (${this.chatState.selectedOutfit[speaker.anonymizedId]}).`);
        }
    }

    async beforePrompt(userMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[userMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[userMessage.anonymizedId], userMessage.content);
        }
        // await this.backgroundCheck(userMessage.content);
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    fallbackClassify(text: string): string {
        const lowered = text.toLowerCase();
        let result = 'neutral';
        Object.values(Emotion).forEach(emotion => {
            if(lowered.includes(emotion.toLowerCase())) {
                result = emotion;
            }
        });
        return result;
    }

    async afterResponse(botMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[botMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[botMessage.anonymizedId], botMessage.content);
        }

        // await this.backgroundCheck(botMessage.content);

        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    async wrapPromise(promise: Promise<void>|null, message: string): Promise<void> {
        if (!promise) {
            promise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve(void 0);
                }, 3000);
            });
        }
        if (this.messageHandle) {
            this.messageHandle.addLoadingMessage(promise, message);
        }
        return promise;
    }

    pickOutfits(speakerId: string, test: (outfit: OutfitType) => boolean): WardrobeType {
        const wardrobe = this.wardrobes[speakerId];
        return wardrobe ? {
            speakerId: speakerId,
            outfits: Object.keys(wardrobe.outfits).reduce((acc: {[key: string]: OutfitType}, outfitKey: string) => {
                if (wardrobe.outfits[outfitKey] && test(wardrobe.outfits[outfitKey])) {
                    acc[outfitKey] = wardrobe.outfits[outfitKey];
                }
                return acc;
            }, {})
        } : {
            speakerId: speakerId,
            outfits: {}
        };
    }

    async readCharacterWardrobesFromStorage(speakerIds: string[]): Promise<{[key: string]: WardrobeType}> {
        // A speakerId is either a character ID or a persona ID.
        // A speakerId can have both per-chat and global wardrobes that need to be loaded and combined.

        const wardrobeFetches = [
            // TODO: get() needs a forChat()
            this.storage.query(
                {
                    keys: ['local_wardrobe'],
                    chat_local: true,
                    character_ids: speakerIds.filter(id => this.isSpeakerIdCharacterId(id))
                }),
            this.storage.query(
                {
                    keys: ['local_wardrobe'],
                    chat_local: true,
                    character_ids: speakerIds.filter(id => !this.isSpeakerIdCharacterId(id)),
                    user_ids: speakerIds.filter(id => !this.isSpeakerIdCharacterId(id))
                }),
            this.storage.get('global_wardrobe').forCharacters(speakerIds.filter(id => this.isSpeakerIdCharacterId(id))),
            this.storage.get('global_wardrobe').forCharacters(speakerIds.filter(id => !this.isSpeakerIdCharacterId(id))).forUsers(speakerIds.filter(id => !this.isSpeakerIdCharacterId(id))),
        ];

        // Load all wardrobes in parallel
        const allWardrobes = await Promise.all(wardrobeFetches.map(async promise => {const response = await promise; console.log(response); return response}));

        const finalWardrobes = allWardrobes.map(response => response.data).flat().filter(item => item.character_id).reduce((acc: {[key: string]: WardrobeType}, item) => {
            // Combine the wardrobes
            const key = item.character_id ?? '';
            const value = item.value as WardrobeType;
            acc[key] = acc[key] ? {...acc[key], outfits: {...acc[key].outfits, ...value.outfits } } : value;
            return acc;
        }, {});

        console.log('Final, assembled, fetched wardrobes:');
        console.log(finalWardrobes);

        return finalWardrobes;
    }

    async updateWardrobeStorage() {

        const remoteWardrobes: {[key: string]: WardrobeType} = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
        // Should check for differences in wardrobes between existingWardrobes and this.backupWardrobes, then apply non-conflicting changes to this.wardrobes before saving.
        // Bear in mind that this.backupWardrobes will have non-generated outfits, while we expect existingWardrobes to have only generated outfits.
        // Compare existingWardrobes against this.backupWardrobes to find differences in generated outfits:
        Object.keys(remoteWardrobes).forEach((speakerId) => {
            if (this.backupWardrobes[speakerId]) {
                for (let outfitKey of Object.keys(remoteWardrobes[speakerId].outfits)) {
                    // If the outfit exists in existingWardrobes but not in backup, it means it was added by another user
                    // We need to add it to this.wardrobes.
                    if (!this.backupWardrobes[speakerId].outfits[outfitKey] && Object.keys(remoteWardrobes[speakerId].outfits[outfitKey].images).length > 0) {
                        console.log(`Outfit ${outfitKey} was added for ${speakerId}`);
                        this.wardrobes[speakerId].outfits[outfitKey] = remoteWardrobes[speakerId].outfits[outfitKey];
                    } else if (this.backupWardrobes[speakerId].outfits[outfitKey] && !this.wardrobes[speakerId].outfits[outfitKey]) {
                        // If the outfit exists in backup but not in this.wardrobes, it means it was removed locally.
                        console.log(`Outfit ${outfitKey} was removed for ${speakerId}`);
                        // No action is taken; the deletion will be pushed below.
                    } else {
                        // If the outfit exists in both existingWardrobes and backup, we need to compare images to see if any need to be updated.
                        // Be smart about this; some images may have been updated in this.wardrobes. We only want to apply differences and not all images.
                        console.log(`Outfit ${outfitKey} exists in both existing and backup wardrobes for ${speakerId}. Checking images...`);

                        const existingImages = remoteWardrobes[speakerId].outfits[outfitKey].images || {};
                        const backupImages = this.backupWardrobes[speakerId].outfits[outfitKey].images || {};
                        const currentImages = this.wardrobes[speakerId].outfits[outfitKey].images || {};
                        
                        // Compare each emotion/image key
                        Object.keys(existingImages).forEach((emotionKey) => {
                            const existingImageUrl = existingImages[emotionKey];
                            const backupImageUrl = backupImages[emotionKey];
                            
                            // If the image exists in existing but not in backup, it was added externally
                            if (existingImageUrl && !backupImageUrl) {
                                console.log(`Image for emotion '${emotionKey}' was added externally for ${speakerId}/${outfitKey}`);
                                this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                            }
                            // If the image exists in both but has different URLs, it was updated externally
                            else if (existingImageUrl && backupImageUrl && existingImageUrl !== backupImageUrl) {
                                // Only apply if we haven't locally modified this image since backup
                                if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImageUrl) {
                                    console.log(`Image for emotion '${emotionKey}' was updated externally for ${speakerId}/${outfitKey}`);
                                    this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                                } else {
                                    console.log(`Image for emotion '${emotionKey}' has conflicting changes - keeping local version for ${speakerId}/${outfitKey}`);
                                }
                            }
                        });
                        
                        // Check for images that were removed externally
                        Object.keys(backupImages).forEach((emotionKey) => {
                            if (backupImages[emotionKey] && !existingImages[emotionKey]) {
                                // Only remove if we haven't locally modified this image since backup
                                if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImages[emotionKey]) {
                                    console.log(`Image for emotion '${emotionKey}' was removed externally for ${speakerId}/${outfitKey}`);
                                    delete this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey];
                                } else {
                                    console.log(`Image for emotion '${emotionKey}' was removed externally but has local changes - keeping local version for ${speakerId}/${outfitKey}`);
                                }
                            }
                        });

                        // Check for outfit name, generatedDescription, and triggerWords:
                        if (remoteWardrobes[speakerId].outfits[outfitKey].name && 
                            this.wardrobes[speakerId].outfits[outfitKey].name !== remoteWardrobes[speakerId].outfits[outfitKey].name && 
                            this.wardrobes[speakerId].outfits[outfitKey].name == this.backupWardrobes[speakerId].outfits[outfitKey].name) {
                            console.log(`Outfit name changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].name}' to '${remoteWardrobes[speakerId].outfits[outfitKey].name}'`);
                            this.wardrobes[speakerId].outfits[outfitKey].name = remoteWardrobes[speakerId].outfits[outfitKey].name;
                        }
                        if (remoteWardrobes[speakerId].outfits[outfitKey].artPrompt && 
                            this.wardrobes[speakerId].outfits[outfitKey].artPrompt !== remoteWardrobes[speakerId].outfits[outfitKey].artPrompt &&
                            this.wardrobes[speakerId].outfits[outfitKey].artPrompt == this.backupWardrobes[speakerId].outfits[outfitKey].artPrompt) {
                            console.log(`Outfit description changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].artPrompt}' to '${remoteWardrobes[speakerId].outfits[outfitKey].artPrompt}'`);
                            this.wardrobes[speakerId].outfits[outfitKey].artPrompt = remoteWardrobes[speakerId].outfits[outfitKey].artPrompt;
                        }
                        if (remoteWardrobes[speakerId].outfits[outfitKey].triggerWords && 
                            this.wardrobes[speakerId].outfits[outfitKey].triggerWords !== remoteWardrobes[speakerId].outfits[outfitKey].triggerWords &&
                            this.wardrobes[speakerId].outfits[outfitKey].triggerWords == this.backupWardrobes[speakerId].outfits[outfitKey].triggerWords) {
                            console.log(`Outfit trigger words changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].triggerWords}' to '${remoteWardrobes[speakerId].outfits[outfitKey].triggerWords}'`);
                            this.wardrobes[speakerId].outfits[outfitKey].triggerWords = remoteWardrobes[speakerId].outfits[outfitKey].triggerWords;
                        }
                    }
                }
                // Compare outfits:
                Object.keys(this.backupWardrobes[speakerId].outfits).forEach((outfitName) => {
                    if (this.backupWardrobes[speakerId].outfits[outfitName] && !remoteWardrobes[speakerId].outfits[outfitName]) {
                        // If the outfit exists in backup but not in existing, it means it was removed
                        console.log(`Outfit ${outfitName} was removed for ${speakerId}`);
                    }
                });
            }
        });

        // Push current wardrobes
        console.log('Pushing wardrobe updates to storage.');

        // Build updates for this persona's stuff:
        let updateBuilder = this.storage.set('local_wardrobe', this.pickOutfits(this.userId, outfit => outfit.generated && !outfit.global)).forCharacter(this.userId).forUser().forChat()
                .set('global_wardrobe', this.pickOutfits(this.userId, outfit => outfit.generated && outfit.global)).forCharacter(this.userId).forUser();

        // Add updates for editable or owned characters:
        for (let speakerId of Object.keys(this.wardrobes)) {
            if (this.wardrobes[speakerId] && this.wardrobes[speakerId].outfits) {
                if (this.isSpeakerIdCharacterId(speakerId)) {
                    if (this.canEdit.includes(speakerId)) {
                        updateBuilder = updateBuilder.set('local_wardrobe', this.pickOutfits(speakerId, outfit => outfit.generated && !outfit.global)).forCharacter(speakerId).forChat();
                    }
                    if (this.owns.includes(speakerId)) {
                        updateBuilder = updateBuilder.set('global_wardrobe', this.pickOutfits(speakerId, outfit => outfit.generated && outfit.global)).forCharacter(speakerId);
                    }
                }
            }
        }

        // Need to await all wardrobePromises, but also want to log their results
        const response = await updateBuilder;
        console.log(response);

        // With everything reconciled and updated, set backup to a copy of wardrobes.
        this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));

    }

    async updateChatState() {
        await this.messenger.updateChatState(this.chatState);
    }

    buildArtPrompt(speaker: Speaker, outfit: string, emotion: Emotion): string {
        const generatedDescription = this.wardrobes[speaker.anonymizedId]?.outfits?.[outfit]?.artPrompt ?? '';
        if (generatedDescription) {
            return `(Art style: ${this.artStyle}), (${generatedDescription}), ((${CHARACTER_ART_PROMPT})), (${EMOTION_PROMPTS[emotion]})`;
        }
        return `No art prompt yet available for ${speaker.name} (${outfit}). Enter a custom prompt below or leave it blank to have the LLM craft an art prompt from context.`;
    }

    async generateSpeakerImagePrompt(speaker: Speaker, outfitKey: string): Promise<void> {
        // Must first build a visual description for this character:
        console.log(`Generating a physical description of ${speaker.name}.`);
        const outfitName = this.wardrobes[speaker.anonymizedId].outfits[outfitKey].name;
        const imageDescription = await this.generator.textGen({
            prompt:
                `Chat History:\n{{messages}}\n\n` +
                (outfitName != DEFAULT_OUTFIT_NAME ? `New Outfit:\n${outfitName}\n\n` : '') +
                `Information about ${speaker.name}:\n${this.getSpeakerDescription(speaker)}\n\n` +
                `Instruction:\nThe goal of this request is to digest the information about ${speaker.name} and construct a simple, comprehensive, and functional visual description of ${speaker.name}. ` +
                `The chat history may involve other characters, but this system response will fixate on ${speaker.name}, forsaking other characters or background details. ` +
                `The result will be fed directly into an image generator, which is unfamiliar with this character, ` +
                `so use concise tags and keywords to convey all essential visual details about them, ` +
                `presenting ample and exhaustive character appearance notes--particularly if they seem obvious: gender, race, skin tone, hair do/color, physique, body shape, outfit, fashion, setting/theme, style, etc. ` +
                (outfitName != DEFAULT_OUTFIT_NAME ?
                    `Describe and emphasize that ${speaker.name} is wearing this prescribed outfit or vibe: ${outfitName}. Develop authentic visual details for the outfit. Aside from that, ` :
                    `Chat history is provided for potential context on ${speaker.name}'s current look; `) +
                `focus on persistent physical details over fleeting ones as this description will be applied to a variety of situations. Output the final visual description below.\n\n` +

                `Sample Response:\nWoman, tall, youthful, dark flowing hair, dark brown hair, loose wavy hair, tanned skin, muscular, modern clothes, worn jeans, dark red bomber jacket, dark brown eyes, thin lips, red and white running shoes, white tanktop.\n\n` +
                `Sample Response:\nMan in a billowing tattered cloak, Medieval fantasy, sinister appearance, dark hair, middle-aged, hair graying at temples, sallow face, elaborate wooden staff, green gem in staff, dark robes with green highlights.\n\n` +
                `Sample Response:\nA willowy androgynous figure, short spiky hair, pale skin, wearing a sleek black bodysuit with silver accents, futuristic cyberpunk style, glowing blue tattoos on arms, piercing blue eyes.\n\n` +
                '',
            min_tokens: 50,
            max_tokens: 140,
            include_history: true
        });
        if (imageDescription?.result) {
            console.log(`Received an image description: ${imageDescription.result}`);
            this.wardrobes[speaker.anonymizedId].outfits[outfitKey].artPrompt = imageDescription.result;
            await this.updateChatState();
        } else {
            return;
        }
    }

    async generateSpeakerImage(speaker: Speaker, outfitKey: string, emotion: Emotion): Promise<void> {
        const outfitName = (this.wardrobes[speaker.anonymizedId].outfits[outfitKey]?.name ?? outfitKey);

        if (!this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]?.artPrompt) {
            await this.generateSpeakerImagePrompt(speaker, outfitKey);
        }

        // Must do neutral first:
        if (emotion != Emotion.neutral && !this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral]) {
            emotion = Emotion.neutral;
        }
        console.log(`Generating ${emotion} image for ${speaker.name} (${outfitName}).`)
        if (emotion == Emotion.neutral) {
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(this.buildArtPrompt(speaker, outfitKey, emotion)),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            // Clear entire pack then assign this image:
            this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images = {};
            this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral] = imageUrl;
        } else {
            const imageUrl = (await this.generator.imageToImage({
                image: this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral],
                prompt: substitute(`(Art style: ${this.artStyle}), (${this.wardrobes[speaker.anonymizedId].outfits[outfitKey].artPrompt}), (${CHARACTER_ART_PROMPT}), ((Strong Emotion: ${EMOTION_PROMPTS[emotion]}))`),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true,
                strength: 0.1
            }))?.url ?? this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral] ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[emotion] = imageUrl;
        }
        await this.updateChatState();
    }

    async backgroundCheck(content: string): Promise<void> {
        // Repurpose this for triggering background swaps to known backgrounds based on key words
    }

    async generateBackgroundImage(character: Speaker, background: Background, content: string): Promise<void> {
        // Must first build a visual description for the background
        if (!this.generateBackgrounds) return;
        if (!background.artPrompt) {
            console.log(`Generate a description of the background.`);
            const imageDescription = await this.generator.textGen({
                prompt:
                    ((character && 'personality' in character) ? `Information about ${character.name}, for Flavor:\n${character.personality}` : '') +
                    `Chat History:\n{{messages}}\n\n` +
                    `Current Instruction:\nThe goal of this task is to digest the flavor text and chat history to construct a comprehensive and concise visual description of ` +
                        (content ? `this background scenery: ${content}.` : `the current scenery. `) +
                    `This system response will be fed directly into an image generator, which is unfamiliar with the setting; ` +
                    `use tags and keywords to convey all essential details about the location, ambiance, weather, or time of day (as applicable), ` +
                    `presenting ample appearance notes. Fixate on the visual details of the surroundings, ignoring action or characters.\n\n` +
                    `Sample Response:\nDesolate wasteland, sandy, oppressively bright, glare, cracked earth, forlorn crags.\n\n` +
                    `Sample Response:\nSmall-town America, charming street, quaint houses, alluring shopfronts, crisp fall foliage.\n\n` +
                    `Sample Response:\nCramped sci-fi hallway, dim emergency lighting, aboard a space station, haunting shapes, loose ducts.\n\n` +
                    `Sample Response:\nForgotten ruins, mossy worn stonework, dense forest, swampy surroundings, entrance leading deep into the unknown, pervasive mist.`,
                min_tokens: 50,
                max_tokens: 150,
                include_history: true
            });
            if (imageDescription?.result) {
                console.log(`Received an image description: ${imageDescription.result}. Generating a background.`);
                background.artPrompt = imageDescription.result;
            }
        }
        if (!background.artPrompt) {
            // Display error message about failed art prompt:
            console.warn(`Failed to generate a background description. Cannot generate background image.`);
            return;
        }
        const imageUrl = (await this.generator.makeImage({
            prompt: substitute(`(Art style: ${this.artStyle}), (${BACKGROUND_ART_PROMPT}), (${background.artPrompt})`),
            aspect_ratio: AspectRatio.CINEMATIC_HORIZONTAL,
        }))?.url ?? '';
        if (imageUrl == '') {
            console.warn(`Failed to generate a background image.`);
        } else {
            background.backgroundUrl = imageUrl;
        }

        await this.generateBackgroundProperties(background);
    }

    async generateBackgroundProperties(background: Background) {
        if (!background.backgroundUrl) {
            return;
        }

        if (this.useBackgroundDepth) {
            try {
                // This endpoint takes actual image data and not a URL; need to load data from imageUrl
                const response = await fetch(background.backgroundUrl);
                const imageBlob = await response.blob();
                const depthPromise = this.depthPipeline.predict("/on_submit", {image: imageBlob});

                // Need to get a HtmlImageElement for getPalette:
                const imageElement = document.createElement('img');
                imageElement.src = URL.createObjectURL(imageBlob);
                // Wait for the image to load before calling getPalette
                await new Promise((resolve) => {
                    imageElement.onload = resolve;
                });

                // Get colors and sort by "brightness"; map to CSS hex color from rgb
                const colors = this.colorThief.getPalette(imageElement, 10).sort((a, b) => {
                    const brightnessA = a[0] * 0.299 + a[1] * 0.587 + a[2] * 0.114;
                    const brightnessB = b[0] * 0.299 + b[1] * 0.587 + b[2] * 0.114;
                    return brightnessB - brightnessA;
                }).map(c => `#${c.map(channel => channel.toString(16).padStart(2, '0')).join('')}`);

                console.log(`Color palette: ${colors}`);
                background.highlightColor = background.highlightColor == DEFAULT_HIGHLIGHT_COLOR ? colors[0] : background.highlightColor;
                background.borderColor = background.borderColor == DEFAULT_BORDER_COLOR ? colors[Math.floor(colors.length / 2)] : background.borderColor;
                background.depthUrl = '';
                const depthResponse = await depthPromise;
                // Depth URL is the HF URL; back it up to Chub by creating a File from the image data:
                const imageFile: File = new File([await (await fetch(depthResponse.data[1].url)).blob()], `${background.id}_depth.png`, {type: 'image/png'});
                const updateResponse = await this.storage.set(`${background.id}_depth.png`, imageFile).forUser();
                background.depthUrl = updateResponse.data[0].value;
                await this.updateBackgroundsStorage();
            } catch (err) {
                console.warn(`Failed to generate palette or depth map for background image: ${err}`);
            }
        }
    }

    async readBackgroundsFromStorage(): Promise<{[key: string]: Background}> {
        const backgroundFetches = [
            this.storage.query({
                chat_local: true,
                character_ids: ['1'],
                keys: ['local_backgrounds']
            }),
            this.storage.get('global_backgrounds').forCharacters(['1'])
        ];

        const backgroundResponses = await Promise.all(backgroundFetches.map(async promise => {const response = await promise; console.log(response); return response}));

        // Combine responses:
        const finalBackgrounds: {[key: string]: Background} = backgroundResponses.map(response => response.data).flat().reduce((acc: {[key: string]: Background}, item) => {
            const value = item.value as Background;
            const key = value?.id ?? '';
            if (key && value) {
                acc[key] = value;
            }
            return acc;
        }, {});
    
        return finalBackgrounds;
    }

    async updateBackgroundsStorage() {
        if (!this.generateBackgrounds) return;
        // Read backgrounds from remote storage:
        const remoteBackgrounds = await this.readBackgroundsFromStorage();

        // Similar to updating wardrobes, we compare remoteBackgrounds against backupBackgrounds to determine remote changes and apply those to this.backgrounds
        for (const [id, background] of Object.entries(remoteBackgrounds)) {
            // Remote change, but no change between backup and current local background; override local background
            if (JSON.stringify(this.backupBackgrounds[id]) !== JSON.stringify(background) && JSON.stringify(this.backgrounds[id]) === JSON.stringify(this.backupBackgrounds[id])) {
                console.log(`Remote background ${id} has changed; updating local background.`);
                this.backgrounds[id] = background;
            }
        }

        // Differences have been reconciled: push changes to remote
        const localBackgrounds = Object.keys(this.backgrounds).reduce((acc: {[key: string]: Background}, backgroundKey: string) => {
                if (backgroundKey && !this.backgrounds[backgroundKey].global) {
                    acc[backgroundKey] = this.backgrounds[backgroundKey];
                }
                return acc;
            }, {})
        console.log(`Pushing local backgrounds:`, localBackgrounds);
        await this.storage.set('local_backgrounds', localBackgrounds).forCharacter('1').forChat();
        if (this.owns['1']) {
            const globalBackgrounds = Object.keys(this.backgrounds).reduce((acc: {[key: string]: Background}, backgroundKey: string) => {
                if (backgroundKey && this.backgrounds[backgroundKey].global) {
                    acc[backgroundKey] = this.backgrounds[backgroundKey];
                }
                return acc;
            }, {});
            console.log(`Pushing global backgrounds:,`, globalBackgrounds);
            await this.storage.set('global_backgrounds', globalBackgrounds).forCharacter('1');
        }
        // Update backupBackgrounds for later comparison.
        this.backupBackgrounds = JSON.parse(JSON.stringify(this.backgrounds));
    }

    async singleSpeakerCheck(speaker: Speaker) {
        const SINGLE_CHARACTER_LABEL = `a character named ${speaker.name}`;
        const MULTI_CHARACTER_LABEL = `multiple characters named ${speaker.name}`;
        const NARRATOR_LABEL = 'a narrator, setting, or scenario';
        try {
            const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                    sequence: `Name: ${speaker.name}\nDescription: ${this.getSpeakerDescription(speaker)}`,
                    candidate_labels: [SINGLE_CHARACTER_LABEL, MULTI_CHARACTER_LABEL, NARRATOR_LABEL],
                    hypothesis_template: `The focus is {}.`,
                    multi_label: true
                })});
            const result = JSON.parse(`${response.data[0]}`);
            console.log('Zero-shot result:');
            console.log(result);
            if (result.labels && result.labels[0] != SINGLE_CHARACTER_LABEL) {
                console.log(`${speaker.name} determined to be non-solo character.`);
                return false;
            }
        } catch (except) {
            console.warn(except);
        }
        return true;
    }

    isSpeakerIdCharacterId(speakerId: string): boolean {
        return this.isSpeakerCharacter(this.speakers[speakerId]);
    }

    isSpeakerCharacter(speaker: Speaker): boolean {
        return speaker && 'personality' in speaker;
    }

    getSpeakerDescription(speaker: Speaker) {
        return 'personality' in speaker ? speaker.personality : ('chatProfile' in speaker ? speaker.chatProfile : '');
    }

    getSpeakerEmotion(anonymizedId: string): Emotion {
        return this.messageState.speakerEmotion[anonymizedId] as Emotion ?? Emotion.neutral;
    }

    getSpeakerImage(anonymizedId: string, outfit: string, emotion: Emotion, defaultUrl: string): string {
        return this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[EMOTION_MAPPING[emotion] ?? emotion] ?? this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[Emotion.neutral] ?? defaultUrl;
    }

    isSpeakerInUi(speaker: Speaker) {
        return !speaker.isRemoved;
    }
    isSpeakerActive(speaker: Speaker) {
        return speaker.anonymizedId == this.messageState.activeSpeaker
    }
    isSpeakerVisible(speaker: Speaker) {
        // Characters default to true, Users to false
        return this.chatState.speakerVisible[speaker.anonymizedId] ?? ('personality' in speaker);
    }
    isSpeakerDisplayed(speaker: Speaker) {
        return this.isSpeakerActive(speaker) || (this.isSpeakerInUi(speaker) && this.isSpeakerVisible(speaker));
    }

    getSelectedBackground(): Background {
        if (!this.generateBackgrounds || Object.keys(this.backgrounds).length == 0) {
            console.warn('No backgrounds available or background generation is disabled. Returning default background.');
            return {
                    id: '',
                    name: 'Default Background',
                    artPrompt: '',
                    backgroundUrl: '',
                    depthUrl: '',
                    borderColor: DEFAULT_BORDER_COLOR,
                    highlightColor: DEFAULT_HIGHLIGHT_COLOR,
                    triggerWords: '',
                    global: false
                };
        }
        if (!this.backgrounds[this.chatState.selectedBackground]) {
            this.chatState.selectedBackground = Object.keys(this.backgrounds)[0];
        }
        return this.backgrounds[this.chatState.selectedBackground];
    }

    async setSelectedBackground(backgroundId: string): Promise<void> {
        if (this.backgrounds[backgroundId]) {
            this.chatState.selectedBackground = backgroundId;
        } else {
            this.chatState.selectedBackground = Object.keys(this.backgrounds)[0];
        }
        await this.updateBackground();
    }
    
    createNewBackground(name: string = 'New Background'): Background {
        const backgroundId = generateUUID();
        return {
            id: backgroundId,
            name: name,
            artPrompt: '',
            backgroundUrl: '',
            depthUrl: '',
            borderColor: DEFAULT_BORDER_COLOR,
            highlightColor: DEFAULT_HIGHLIGHT_COLOR,
            triggerWords: '',
            global: false
        };
    }

    render(): ReactElement {
        return(
            <div className="big-stacker"
                key={'big-over-stacker'}
                style={{
                    width: '100vw',
                    height: '100vh',
                    position: 'relative',
                    alignItems: 'stretch',
                    overflow: 'hidden'
                }}
            >
                <ThemeProvider theme={darkTheme}>
                    <NewSpeakerSettings
                        register={(handle) => {this.speakerSettingsHandle = handle;}}
                        stage={this}
                        borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                        onRegenerate={(char, outfit, emotion) => {
                            this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${this.wardrobes[char.anonymizedId].outfits[outfit].name}).`);
                        }}
                        />
                    <BackgroundSettings
                        register={(handle) => {this.backgroundSettingsHandle = handle;}}
                        stage={this}
                        borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                        onRegenerate={(background) => {
                            this.wrapPromise(this.generateBackgroundImage(Object.values(this.speakers)[0], background, background.name), `Generating background for ${background.name}.`);
                        }}
                    />
                    <MessageQueue register={(handle) => {this.messageHandle = handle;}} borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}/>
                    {/* Regenerate buttons for each character */}
                    <div style={{display: "flex", flexDirection: "column", gap: 10, alignItems: "end"}}>
                        {Object.values(this.speakers).filter(c => this.isSpeakerInUi(c)).map((speaker, i) => (
                            <SpeakerButton
                                key={`character_options_${speaker.anonymizedId}`}
                                speaker={speaker}
                                stage={this}
                                borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                                onOpenSettings={(sp) => this.speakerSettingsHandle?.setSpeaker(sp)}
                            />
                        ))}
                        {/* Background button */}
                        {this.generateBackgrounds && <BackgroundButton
                            key="background_options"
                            stage={this}
                            borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                            onOpenSettings={(bg) => this.backgroundSettingsHandle?.setOpen(true)}
                        />}
                    </div>
                    <Scene imageUrl={this.getSelectedBackground().backgroundUrl} depthUrl={this.getSelectedBackground().depthUrl} stage={this}/>
                </ThemeProvider>
            </div>

        );
    }

}
