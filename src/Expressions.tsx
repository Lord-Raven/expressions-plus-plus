import {ReactElement} from "react";
import {StageBase, StageResponse, InitialData, Message} from "@chub-ai/stages-ts";
import {LoadResponse} from "@chub-ai/stages-ts/dist/types/load";
import { Client } from "@gradio/client";

type MessageStateType = { [key: string]: Emotion };
type ConfigType = {
    // Optional. The alternate expression packs to use.
    selected?: {[key: string]: string} | null
    autoGenerate?: boolean
};

enum EmotionEnum {
    admiration = 'admiration',
    amusement = 'amusement',
    anger = 'anger',
    annoyance = 'annoyance',
    approval = 'approval',
    caring = 'caring',
    confusion = 'confusion',
    curiosity = 'curiosity',
    desire = 'desire',
    disappointment = 'disappointment',
    disapproval = 'disapproval',
    disgust = 'disgust',
    embarrassment = 'embarrassment',
    excitement = 'excitement',
    fear = 'fear',
    gratitude = 'gratitude',
    grief = 'grief',
    joy = 'joy',
    love = 'love',
    nervousness = 'nervousness',
    optimism = 'optimism',
    pride = 'pride',
    realization = 'realization',
    relief = 'relief',
    remorse = 'remorse',
    sadness = 'sadness',
    surprise = 'surprise',
    neutral = 'neutral',
}

type Emotion = {
    [key in keyof typeof EmotionEnum]: string;
}[keyof typeof EmotionEnum];

const EMOTIONS = new Set<string>(Object.values(EmotionEnum));

type EmotionPack = {
    // If auto-generated, make sure this is saved to chat state.
    autoGenerated: boolean;
    imageUrls:{[K in Emotion]?: string};
};

type InitStateType = null;

type ChatStateType = {
    generatedEmotionPacks:{[key: string]: {[K in Emotion]?: string}};
};

export class Expressions extends StageBase<InitStateType, ChatStateType, MessageStateType, ConfigType> {

    charsToPacks: {[key: string]: EmotionPack}
    charsToEmotions: {[key: string]: Emotion}
    pipeline: any
    hasPack: boolean
    autoGenerate: boolean

    constructor(data: InitialData<InitStateType, ChatStateType, MessageStateType, ConfigType>) {
        super(data);
        const {
            characters,
            config,
            messageState,
            chatState
        } = data;

        console.log("constructing");

        this.charsToEmotions = {};
        this.charsToPacks = {};
        this.hasPack = false;
        this.pipeline = null;
        this.autoGenerate = config?.autoGenerate ?? true;


        // Very very ugly, but just loading up emotion packs and current state,
        // with a lot of ick from most fields being optional/possibly-undefined
        // instead of nice and clean.
        Object.keys(characters).forEach((charAnonId: string) => {
            if(!characters[charAnonId].isRemoved) {
                console.log(characters[charAnonId]);
                console.log(characters[charAnonId].partial_extensions);
                this.charsToEmotions[charAnonId] = messageState != null && messageState.hasOwnProperty(charAnonId) && EMOTIONS.has(messageState[charAnonId]) ? messageState[charAnonId] : 'neutral';

                if (characters[charAnonId]?.partial_extensions?.chub?.expressions?.expressions != null) {
                    console.log('This should happen.');
                    this.charsToPacks[charAnonId] = {autoGenerated: false, imageUrls: characters[charAnonId].partial_extensions?.chub?.expressions?.expressions};
                    this.hasPack = true;
                } else if (chatState?.generatedEmotionPacks[charAnonId]) {
                    console.log('This happened instead.');
                    this.charsToPacks[charAnonId] = {autoGenerated: true, imageUrls: chatState.generatedEmotionPacks[charAnonId]};
                    this.hasPack = false; // Should set this to true, but want to test this out.
                } else {
                    this.charsToPacks[charAnonId] = {autoGenerated: this.autoGenerate, imageUrls: {}};
                    this.hasPack = false; // Should set this to: this.hasPack || this.autoGenerate;
                }
                if(config != null && config.selected != null
                    && config.selected?.hasOwnProperty(charAnonId)
                    && config.selected[charAnonId] != null
                    && config.selected[charAnonId] != ''
                    && config.selected[charAnonId].toLowerCase() != 'default'
                    && characters[charAnonId]?.partial_extensions.chub.alt_expressions != null
                && config.selected[charAnonId] in characters[charAnonId]?.partial_extensions.chub.alt_expressions) {
                    console.log("Great!");
                    this.charsToPacks[charAnonId] = characters[charAnonId].partial_extensions
                        .chub.alt_expressions[config.selected![charAnonId]].expressions;
                }
            }
        });

        console.log("done constructing");
    }

    async load(): Promise<Partial<LoadResponse<InitStateType, ChatStateType, MessageStateType>>> {
        console.log("loading");

        try {
            this.pipeline = await Client.connect("ravenok/emotions");
        } catch (except: any) {
            console.error(`Error loading expressions pipeline, error: ${except}`);
            return { success: true, error: null }
        }
        console.log(`done loading: ${this.hasPack}`);
        return {
            success: this.hasPack,
            error: null
        };
    }

    async setState(state: MessageStateType): Promise<void> {
        if (state != null) {
            this.charsToEmotions = {...this.charsToEmotions, ...state};
        }
    }

    async beforePrompt(userMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {
        // Don't really care about this.
        return {
            extensionMessage: null,
            stageDirections: null,
            messageState: this.charsToEmotions,
            modifiedMessage: null,
            error: null
        };
    }

    fallbackClassify(text: string): string {
        const lowered = text.toLowerCase();
        let result = 'neutral';
        Object.values(EmotionEnum).forEach(emotion => {
            if(lowered.includes(emotion.toLowerCase())) {
                result = emotion;
            }
        });
        return result;
    }

    async afterResponse(botMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {
        let newEmotion = 'neutral';
        if(this.pipeline != null) {
            try {
                const emotionResult = (await this.pipeline.predict("/predict", {
                    param_0: botMessage.content,
                }))
                console.log(`Emotion result: ${emotionResult}`);
                newEmotion = emotionResult.data[0].confidences.find((confidence: {label: string, score: number}) => confidence.label != 'neutral' && confidence.score > 0.2)?.label ?? newEmotion;
            } catch (except: any) {
                console.warn(`Error classifying expression, error: ${except}`);
                newEmotion = this.fallbackClassify(botMessage.content);
            }
        } else {
            newEmotion = this.fallbackClassify(botMessage.content);
        }
        console.info(`New emotion for ${botMessage.anonymizedId}: ${newEmotion}`);
        this.charsToEmotions[botMessage.anonymizedId] = newEmotion;
        return {
            extensionMessage: null,
            stageDirections: null,
            messageState: this.charsToEmotions,
            modifiedMessage: null,
            error: null
        };
    }

    render(): ReactElement {
        return <div className="big-stacker"
                    key={'big-over-stacker'}
                    style={{
            width: '100vw',
            height: '100vh',
            display: 'grid',
            alignItems: 'stretch'
            }}>
            {Object.keys(this.charsToEmotions).map(charId => {
                if(this.charsToEmotions.hasOwnProperty(charId) && this.charsToEmotions[charId] != null &&
                    this.charsToPacks.hasOwnProperty(charId) && this.charsToPacks[charId] != null &&
                    this.charsToPacks[charId].hasOwnProperty(this.charsToEmotions[charId]) &&
                    this.charsToPacks[charId].imageUrls[this.charsToEmotions[charId]] != null
                ) {
                    return <img
                        key={`img-${charId}-${this.charsToEmotions[charId]}`}
                        style={{
                            width: '100%',
                            maxHeight: '100vh',
                            minHeight: '10px',
                            objectFit: 'contain'
                        }}
                        src={this.charsToPacks[charId].imageUrls[this.charsToEmotions[charId]]}
                        alt={''} />
                } else {
                    return <></>
                }
            })}
        </div>;
    }

}
