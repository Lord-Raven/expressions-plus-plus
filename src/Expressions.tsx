import {
    StageBase,
    StageResponse,
    InitialData,
    Message,
    AspectRatio,
    Speaker
} from "@chub-ai/stages-ts";
import {LoadResponse} from "@chub-ai/stages-ts/dist/types/load";
import { Client } from "@gradio/client";
import SpeakerImage from "./SpeakerImage.tsx";
import {ReactElement} from "react";
import BackgroundImage from "./BackgroundImage";
import SpeakerButton from "./SpeakerButton.tsx";
import {createTheme, ThemeProvider} from "@mui/material";
import {MessageQueue, MessageQueueHandle} from "./MessageQueue.tsx";
import {FastAverageColor} from "fast-average-color";
import { AnimatePresence } from "framer-motion";
import SpeakerSettings, {SpeakerSettingsHandle} from "./SpeakerSettings.tsx";
import NewSpeakerSettings from "./NewSpeakerSettings.tsx";

type ChatStateType = {
    generatedWardrobes:{[key: string]: {[key: string]: EmotionPack}};
    selectedOutfit:{[key: string]: string};
    generatedDescriptions:{[key: string]: string};
    speakerVisible:{[key: string]: boolean};
}

type OutfitType = {
    // Description of the outfit, used for generating the image description
    manualDescription: string;
    // Description generated by the AI, used for generating the image
    generatedDescription: string;
    // Images for the outfit, keyed by emotion
    images: EmotionPack;
    // Comma-delimitted list of trigger words that will swap to this outfit
    triggerWords: string;
    // Whether this outfit was generated by this stage or managed by a built-in emotion pack
    generated: boolean;
}

type WardrobeType = {
    speakerId: string;
    outfits: {[key: string]: OutfitType};
}

type ConfigType = {
    artStyle?: string;
    generateCharacters?: string;
    generateBackgrounds?: string;
    selected?: {[key: string]: string} | null;
    alphaMode?: string;
};

type InitStateType = null;

type MessageStateType = {
    backgroundUrl: string;
    borderColor: string;
    speakerEmotion: {[key: string]: string};
    activeSpeaker: string;
};

export enum Emotion {
    neutral = 'neutral',
    admiration = 'admiration',
    amusement = 'amusement',
    anger = 'anger',
    annoyance = 'annoyance',
    approval = 'approval',
    caring = 'caring',
    confusion = 'confusion',
    curiosity = 'curiosity',
    desire = 'desire',
    disappointment = 'disappointment',
    disapproval = 'disapproval',
    disgust = 'disgust',
    embarrassment = 'embarrassment',
    excitement = 'excitement',
    fear = 'fear',
    gratitude = 'gratitude',
    grief = 'grief',
    joy = 'joy',
    love = 'love',
    nervousness = 'nervousness',
    optimism = 'optimism',
    pride = 'pride',
    realization = 'realization',
    relief = 'relief',
    remorse = 'remorse',
    sadness = 'sadness',
    surprise = 'surprise',
}

export const EMOTION_MAPPING: {[emotion in Emotion]?: Emotion} = {
    admiration: Emotion.joy,
    approval: Emotion.amusement,
    caring: Emotion.neutral,
    curiosity: Emotion.neutral,
    disapproval: Emotion.disappointment,
    optimism: Emotion.gratitude,
    realization: Emotion.surprise,
    relief: Emotion.gratitude,
    remorse: Emotion.sadness
}

export const EMOTION_PROMPTS: {[emotion in Emotion]?: string} = {
    neutral: 'calm expression',
    amusement: 'subtle smirk, amused expression',
    anger: 'enraged, angry expression',
    annoyance: 'annoyed, dismayed expression',
    confusion: 'stunned, baffled, confused expression',
    desire: 'sexy, alluring, seductive expression',
    disappointment: 'unhappy, disappointed expression',
    disgust: 'disgusted expression',
    embarrassment: 'embarrassed, blushing, sheepish expression',
    excitement: 'keen, excited expression',
    fear: 'terrified expression',
    gratitude: 'relieved, thankful expression',
    grief: 'depressed, sobbing expression',
    joy: 'happy, smiling',
    love: 'adorable, grinning, blushing, lovestruck expression',
    nervousness: 'nervous, uneasy expression',
    pride: 'proud, haughty, puffed up expression',
    sadness: 'sad, upset expression, teary-eyed',
    surprise: 'shocked, surprised expression',
}


const darkTheme = createTheme({
    palette: {
        mode: 'dark',
        background: {
            default: '#121212',
            paper: '#1e1e1e',
        },
        text: {
            primary: '#ffffff',
            secondary: '#aaaaaa',
        }
    },
});

const CHARACTER_ART_PROMPT: string = 'plain flat background, standing, full body, head-to-toe';
const CHARACTER_NEGATIVE_PROMPT: string = 'border, ((close-up)), scenery, special effects, scene, dynamic angle, action, cut-off';
const BACKGROUND_ART_PROMPT: string = 'unpopulated, visual novel background scenery, background only, scenery only';

const DEFAULT_BORDER_COLOR: string = '#1e1e1edd';
export const DEFAULT_OUTFIT_NAME: string = 'Starter Outfit';

// Replace trigger words with less triggering words, so image gen can succeed.
export function substitute(input: string) {
    const synonyms: [string, string][] = [
        ['old-school', 'retro'],
        ['old school', 'retro'],
        ['oldschool', 'retro'],
        ['schoolgirl', 'college girl'],
        ['school girl', 'college girl'],
        ['schoolboy', 'college guy'],
        ['school boy', 'college guy'],
        ['schoolteacher', 'professor'],
        ['school teacher', 'professor'],
        ['school', 'college'],
        ['youngster', 'individual'],
        ['child', 'individual'],
        ['kid', 'individual'],
        ['young', 'youthful']
    ];

    for (const [key, replacement] of synonyms) {
        const regex = new RegExp(key, 'gi');
        input = input.replace(regex, (match) => {
            return match[0] === match[0].toUpperCase()
                ? replacement.charAt(0).toUpperCase() + replacement.slice(1)
                : replacement;
        });
    }

    return input;
}

type EmotionPack = {[key: string]: string};

export class Expressions extends StageBase<InitStateType, ChatStateType, MessageStateType, ConfigType> {

    // Chat state:
    chatState: ChatStateType;

    // Message state:
    messageState: MessageStateType;

    // Not saved:
    emotionPipeline: any = null;
    zeroShotPipeline: any = null;
    generateCharacters: boolean;
    generateBackgrounds: boolean;
    artStyle: string;
    speakers: {[key: string]: Speaker};
    flagBackground: boolean = false;
    wardrobes: {[key: string]: WardrobeType} = {};
    alphaMode: boolean;

    readonly fac = new FastAverageColor();
    private messageHandle?: MessageQueueHandle;
    private speakerSettingsHandle?: SpeakerSettingsHandle;

    constructor(data: InitialData<InitStateType, ChatStateType, MessageStateType, ConfigType>) {
        super(data);
        const {
            characters,
            config,
            messageState,
            chatState,
            users
        } = data;

        console.log(config);
        console.log(characters);
        console.log(users);

        this.speakers = {...characters, ...users};

        // Set states or default them.
        this.messageState = {
            backgroundUrl: messageState?.backgroundUrl ?? '',
            borderColor: messageState?.borderColor ?? DEFAULT_BORDER_COLOR,
            speakerEmotion: messageState?.speakerEmotion ?? {},
            activeSpeaker: messageState?.activeSpeaker ?? ''
        }

        this.chatState = {
            generatedWardrobes: chatState?.generatedWardrobes ?? {},
            selectedOutfit: chatState?.selectedOutfit ?? {},
            generatedDescriptions: chatState?.generatedDescriptions ?? {},
            speakerVisible: chatState?.speakerVisible ?? {}
        };

        this.generateCharacters = (config?.generateCharacters ?? "True") == "True";
        this.generateBackgrounds = (config?.generateBackgrounds ?? "True") == "True";
        this.alphaMode = (config?.alphaMode ?? "False") == "True";
        this.artStyle = config?.artStyle ?? 'Bold, visual novel style illustration, clean lines';

        if (this.alphaMode) {
            console.warn('Alpha mode enabled. This is experimental and may break things.');
            // If the old generatedWardrobes were loaded, populate wardrobes
            if (this.chatState.generatedWardrobes) {
                this.wardrobes = Object.keys(this.chatState.generatedWardrobes).reduce((acc: {[key: string]: WardrobeType}, charAnonId) => {
                    acc[charAnonId] = {
                        speakerId: charAnonId,
                        outfits: Object.keys(this.chatState.generatedWardrobes[charAnonId] ?? {}).reduce((outfitAcc: {[key: string]: OutfitType}, outfitName) => {
                            outfitAcc[outfitName] = {
                                images: this.chatState.generatedWardrobes[charAnonId][outfitName],
                                manualDescription: outfitName,
                                generatedDescription: this.chatState.generatedDescriptions[`${charAnonId}_${outfitName}`] ?? '',
                                triggerWords: outfitName,
                                generated: true
                            } as OutfitType;
                            return outfitAcc;
                        }, {})
                    } as WardrobeType;
                    return acc;
                }, {});
            }
            // Initialize wardrobes for unloaded characters
            for (let speakerId in Object.keys(this.speakers)) {
                this.wardrobes[speakerId] = this.wardrobes[speakerId] ?? {
                    speakerId: speakerId,
                    outfits: {}
                } as WardrobeType;
            }
            console.log(this.wardrobes);
        }

        // Look at characters, set up packs, and initialize values that aren't present in message/chat state
        Object.keys(this.speakers).forEach((charAnonId: string) => {
            const speaker = this.speakers[charAnonId];
            if (!speaker.isRemoved) {
                if (this.alphaMode && characters[charAnonId]?.partial_extensions?.chub?.expressions?.expressions != null) {
                    console.log('Character has an expressions pack.');
                    // Generate outfit entries for each expressions pack, marked non-generated.
                    for (let expressionPack of Object.values([characters[charAnonId].partial_extensions.chub.expressions])) {
                        this.wardrobes[charAnonId].outfits[expressionPack.version] = {
                            images: expressionPack.expressions,
                            manualDescription: expressionPack.version,
                            generatedDescription: '',
                            generated: false,
                            triggerWords: expressionPack.version,
                        } as OutfitType;
                    }
                    console.log('Loaded an expression pack');
                    console.log(this.wardrobes);
                } else if (this.chatState.generatedWardrobes[charAnonId] && this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME] && Object.keys(this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME]).length > 0) {
                    console.log('Character has a wardrobe.');
                } else {
                    console.log('Initializing a new wardrobe.')
                    this.chatState.generatedWardrobes[charAnonId] = {[DEFAULT_OUTFIT_NAME]: {}};
                    this.chatState.selectedOutfit[charAnonId] = DEFAULT_OUTFIT_NAME;
                }
            }
        });
    }

    async load(): Promise<Partial<LoadResponse<InitStateType, ChatStateType, MessageStateType>>> {
        await this.updateBackground();
        
        try {
            this.emotionPipeline = await Client.connect("ravenok/emotions");
            this.zeroShotPipeline = await Client.connect("ravenok/statosphere-backend");
        } catch (except: any) {
            console.error(`Error loading pipelines, error: ${except}`);
            return { success: false, error: except }
        }

        for (let speaker of Object.values(this.speakers)) {
            if (!(speaker.anonymizedId in this.chatState.speakerVisible)) {
                this.chatState.speakerVisible[speaker.anonymizedId] = !('chatProfile' in speaker);
                //this.singleSpeakerCheck(speaker).then(result => {this.chatState.speakerVisible[speaker.anonymizedId] = result; this.updateChatState()});
            }
        }

        return {
            success: true,
            chatState: this.chatState,
            messageState: this.messageState,
            error: null
        };
    }

    async storeWardrobe(speakerId: string, wardrobe: WardrobeType): Promise<void> {
        await this.storage.set('wardrobe', wardrobe).forCharacter(speakerId);
    }

    async retrieveWardrobe(speakerId: string): Promise<WardrobeType|null> {
        const wardrobeData = (await this.storage.get('wardrobe').forCharacter(speakerId)).data[0].value;
        console.log(wardrobeData);
        return wardrobeData as WardrobeType || null;
    }

    async updateBackground() {
        await this.messenger.updateEnvironment({background: this.messageState.backgroundUrl});
    }

    async setState(state: MessageStateType): Promise<void> {
        if (state != null) {
            this.messageState = {
                backgroundUrl: state?.backgroundUrl ?? '',
                borderColor: state?.borderColor ?? DEFAULT_BORDER_COLOR,
                speakerEmotion: state?.speakerEmotion ?? {},
                activeSpeaker: state?.activeSpeaker ?? ''
            }
            await this.updateBackground();
        }
    }

    async updateEmotion(speaker: Speaker, content: string) {
        let newEmotion = 'neutral';
        if (this.emotionPipeline != null) {
            try {
                const emotionResult = (await this.emotionPipeline.predict("/predict", {
                    param_0: content,
                }))
                console.log(`Emotion result: `);
                console.log(emotionResult.data[0].confidences);
                newEmotion = emotionResult.data[0].confidences.find((confidence: {label: string, score: number}) => confidence.label != 'neutral' && confidence.score > 0.1)?.label ?? newEmotion;
            } catch (except: any) {
                console.warn(`Error classifying expression, error: ${except}`);
                newEmotion = this.fallbackClassify(content);
            }
        } else {
            newEmotion = this.fallbackClassify(content);
        }
        console.info(`New emotion for ${speaker.name}: ${newEmotion}`);
        this.messageState.speakerEmotion[speaker.anonymizedId] = newEmotion;
        this.messageState.activeSpeaker = speaker.anonymizedId;
        if (!this.chatState.generatedWardrobes[speaker.anonymizedId][this.chatState.selectedOutfit[speaker.anonymizedId]][EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion]) {
            this.wrapPromise(
                this.generateSpeakerImage(speaker, this.chatState.selectedOutfit[speaker.anonymizedId], EMOTION_MAPPING[newEmotion as Emotion] ?? (newEmotion as Emotion)),
                `Generating ${newEmotion} for ${speaker.name} (${this.chatState.selectedOutfit[speaker.anonymizedId]}).`);
        }
    }

    async beforePrompt(userMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[userMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[userMessage.anonymizedId], userMessage.content);
        }
        await this.backgroundCheck(userMessage.content);
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    fallbackClassify(text: string): string {
        const lowered = text.toLowerCase();
        let result = 'neutral';
        Object.values(Emotion).forEach(emotion => {
            if(lowered.includes(emotion.toLowerCase())) {
                result = emotion;
            }
        });
        return result;
    }

    async afterResponse(botMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[botMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[botMessage.anonymizedId], botMessage.content);
        }
        await this.backgroundCheck(botMessage.content);
        if (this.flagBackground) {
            await this.wrapPromise(this.generateBackgroundImage(this.speakers[botMessage.anonymizedId], botMessage.content), 'Generating new background image.');
        }
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    async wrapPromise(promise: Promise<void>|null, message: string): Promise<void> {
        if (!promise) {
            promise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve(void 0);
                }, 3000);
            });
        }
        if (this.messageHandle) {
            this.messageHandle.addLoadingMessage(promise, message);
        }
        return promise;
    }

    async updateChatState() {
        await this.messenger.updateChatState(this.chatState);
    }

    buildArtPrompt(speaker: Speaker, outfit: string, emotion: Emotion): string {
        return `(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`]}), ((${CHARACTER_ART_PROMPT})), (${EMOTION_PROMPTS[emotion]})`;
    }

    async generateSpeakerImage(speaker: Speaker, outfit: string, emotion: Emotion): Promise<void> {
        if (!this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`] || emotion == Emotion.neutral) {
            // Must first build a visual description for this character:
            console.log(`Generating a physical description of ${speaker.name}.`);
            const imageDescription = await this.generator.textGen({
                prompt:
                    `Chat History:\n{{messages}}\n\n` +
                    (outfit != DEFAULT_OUTFIT_NAME ? `New Outfit:\n${outfit}\n\n` : '') +
                    `Information about ${speaker.name}:\n${this.getSpeakerDescription(speaker)}\n\n` +
                    `Sample Response:\nWoman, tall, youthful, dark flowing hair, dark brown hair, loose wavy hair, tanned skin, muscular, modern clothes, worn jeans, dark red bomber jacket, dark brown eyes, thin lips, red and white running shoes, white tanktop.\n\n` +
                    `Sample Response:\nMan in a billowing tattered cloak, Medieval fantasy, sinister appearance, dark hair, middle-aged, hair graying at temples, sallow face, elaborate wooden staff, green gem in staff, dark robes with green highlights.\n\n` +
                    `Current Instruction:\nThe goal of this task is to digest the information about ${speaker.name} and construct a comprehensive and functional visual description of ${speaker.name}. ` +
                    `The chat history may involve other characters, but this system response will fixate on ${speaker.name}; ` +
                    `the result will be fed directly into an image generator, which is unfamiliar with this character, ` +
                    `so use concise tags and keywords to convey all essential details about them, ` +
                    `presenting ample and exhaustive character appearance notes--particularly if they seem obvious: gender, race, skin tone, hair do/color, physique, body shape, outfit, fashion, setting/theme, style, etc. ` +
                    (outfit != DEFAULT_OUTFIT_NAME ?
                        `Describe and emphasize that ${speaker.name} is wearing this prescribed outfit: ${outfit}. Develop authentic visual details for this outfit. Aside from that, ` :
                        `Chat history is provided for context on ${speaker.name}'s current outfit; `) +
                    `focus on persistent physical details over fleeting ones as this description will be applied to a variety of situations.`,
                min_tokens: 50,
                max_tokens: 140,
                include_history: true
            });
            if (imageDescription?.result) {
                console.log(`Received an image description: ${imageDescription.result}`);
                this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`] = imageDescription.result;
                await this.updateChatState();
            } else {
                return;
            }
        }
        // Must do neutral first:
        if (emotion != Emotion.neutral && !this.chatState.generatedWardrobes[speaker.anonymizedId][outfit][Emotion.neutral]) {
            emotion = Emotion.neutral;
        }
        console.log(`Generating ${emotion} image for ${speaker.name} (${outfit}).`)
        if (emotion == Emotion.neutral) {
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(this.buildArtPrompt(speaker, outfit, emotion)),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            // Clear entire pack then assign this image:
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfit] = {};
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfit][Emotion.neutral] = imageUrl;
            /*if (!this.generating) {
                this.generateNextImage(0);
            }*/
        } else {
            const imageUrl = (await this.generator.imageToImage({
                image: this.chatState.generatedWardrobes[speaker.anonymizedId][outfit][Emotion.neutral],
                prompt: substitute(`(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`]}), (${CHARACTER_ART_PROMPT}), ((Strong Emotion: ${EMOTION_PROMPTS[emotion]}))`),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true,
                strength: 0.1
            }))?.url ?? this.chatState.generatedWardrobes[speaker.anonymizedId][outfit][Emotion.neutral] ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfit][emotion] = imageUrl;
        }
        await this.updateChatState();
    }

    async backgroundCheck(content: string): Promise<void> {
        if (this.flagBackground || !this.generateBackgrounds || !content) return;

        if (this.messageState.backgroundUrl) {
            const TRANSITION_LABEL = 'transitions to a new location';
            const STAY_LABEL = 'does not alter the location or setting';
            try {
                const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                        sequence: content,
                        candidate_labels: [STAY_LABEL, TRANSITION_LABEL],
                        hypothesis_template: 'This passage {}.',
                        multi_label: true
                    })});
                const result = JSON.parse(`${response.data[0]}`);
                console.log('Zero-shot result:');
                console.log(result);
                if (result.labels[0] == STAY_LABEL || result.scores[0] < 0.5) {
                    return;
                }
            } catch (except) {
                console.warn(except);
                return;
            }
        }

        this.flagBackground = true;
    }

    async generateBackgroundImage(character: Speaker, content: string): Promise<void> {
        // Must first build a visual description for the background
        this.flagBackground = false
        console.log(`Generate a description of the background.`);
        const imageDescription = await this.generator.textGen({
            prompt:
                ((character && 'personality' in character) ? `Information about ${character.name}, for Flavor:\n${character.personality}` : '') +
                `Chat History:\n{{messages}}\n\n` +
                `Current Instruction:\nThe goal of this task is to digest the flavor text and chat history to construct a comprehensive and concise visual description of the current scenery. ` +
                `This system response will be fed directly into an image generator, which is unfamiliar with the setting; ` +
                `use tags and keywords to convey all essential details about the location, ambiance, weather, or time of day (as applicable), ` +
                `presenting ample appearance notes. Fixate on the visual details of the surroundings, ignoring action or characters.\n\n` +
                `Sample Response:\nDesolate wasteland, sandy, oppressively bright, glare, cracked earth, forlorn crags.\n\n` +
                `Sample Response:\nSmall-town America, charming street, quaint houses, alluring shopfronts, crisp fall foliage.\n\n` +
                `Sample Response:\nCramped sci-fi hallway, dim emergency lighting, aboard a space station, haunting shapes, loose ducts.\n\n` +
                `Sample Response:\nForgotten ruins, mossy worn stonework, dense forest, swampy surroundings, entrance leading deep into the unknown, pervasive mist.`,
            min_tokens: 50,
            max_tokens: 150,
            include_history: true
        });
        if (imageDescription?.result) {
            console.log(`Received an image description: ${imageDescription.result}. Generating a background.`);
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(`(Art style: ${this.artStyle}), (${BACKGROUND_ART_PROMPT}), (${imageDescription.result})`),
                aspect_ratio: AspectRatio.CINEMATIC_HORIZONTAL,
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a background image.`);
            }
            this.messageState.backgroundUrl = imageUrl;
            try {
                this.messageState.borderColor = (await this.fac.getColorAsync(imageUrl)).rgba ?? DEFAULT_BORDER_COLOR;
            } catch(err) {
                this.messageState.borderColor = DEFAULT_BORDER_COLOR;
            }
            await this.updateBackground();
        }
    }


    async singleSpeakerCheck(speaker: Speaker) {
        const SINGLE_CHARACTER_LABEL = `a character named ${speaker.name}`;
        const MULTI_CHARACTER_LABEL = `multiple characters named ${speaker.name}`;
        const NARRATOR_LABEL = 'a narrator, setting, or scenario';
        try {
            const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                    sequence: `Name: ${speaker.name}\nDescription: ${this.getSpeakerDescription(speaker)}`,
                    candidate_labels: [SINGLE_CHARACTER_LABEL, MULTI_CHARACTER_LABEL, NARRATOR_LABEL],
                    hypothesis_template: `The focus is {}.`,
                    multi_label: true
                })});
            const result = JSON.parse(`${response.data[0]}`);
            console.log('Zero-shot result:');
            console.log(result);
            if (result.labels && result.labels[0] != SINGLE_CHARACTER_LABEL) {
                console.log(`${speaker.name} determined to be non-solo character.`);
                return false;
            }
        } catch (except) {
            console.warn(except);
        }
        return true;
    }

    getSpeakerDescription(speaker: Speaker) {
        return 'personality' in speaker ? speaker.personality : ('chatProfile' in speaker ? speaker.chatProfile : '');
    }

    getSpeakerEmotion(anonymizedId: string): Emotion {
        return this.messageState.speakerEmotion[anonymizedId] as Emotion ?? Emotion.neutral;
    }

    getSpeakerImage(anonymizedId: string, outfit: string, emotion: Emotion, defaultUrl: string): string {
        if (this.alphaMode) {
            return this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[EMOTION_MAPPING[emotion] ?? emotion] ?? this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[Emotion.neutral] ?? defaultUrl;
        }
        return this.chatState.generatedWardrobes[anonymizedId][(outfit && outfit in this.chatState.generatedWardrobes[anonymizedId]) ? outfit : DEFAULT_OUTFIT_NAME][EMOTION_MAPPING[emotion] ?? emotion] ?? this.chatState.generatedWardrobes[anonymizedId][outfit][Emotion.neutral] ?? defaultUrl;
    }

    isSpeakerInUi(speaker: Speaker) {
        return !speaker.isRemoved;
    }
    isSpeakerActive(speaker: Speaker) {
        return speaker.anonymizedId == this.messageState.activeSpeaker
    }
    isSpeakerVisible(speaker: Speaker) {
        // Characters default to true, Users to false
        return this.chatState.speakerVisible[speaker.anonymizedId] ?? ('personality' in speaker);
    }
    isSpeakerDisplayed(speaker: Speaker) {
        return this.isSpeakerActive(speaker) || (this.isSpeakerInUi(speaker) && this.isSpeakerVisible(speaker));
    }

    render(): ReactElement {
        const count = Object.values(this.speakers).filter(speaker => this.isSpeakerDisplayed(speaker)).length;
        let index = 0;

        return(
            <div className="big-stacker"
                key={'big-over-stacker'}
                style={{
                    width: '100vw',
                    height: '100vh',
                    position: 'relative',
                    alignItems: 'stretch',
                    overflow: 'hidden'
                }
            }>
                <ThemeProvider theme={darkTheme}>
                    {this.alphaMode ? (
                        <NewSpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.messageState.borderColor}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${outfit}).`);
                            }}
                            />) : (
                        <SpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.messageState.borderColor}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${outfit}).`);
                            }}
                        />)
                    }
                    <MessageQueue register={(handle) => {this.messageHandle = handle;}} borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}/>
                    {/* Regenerate buttons for each character */}
                    <div style={{display: "flex", flexDirection: "column", gap: 10, alignItems: "end"}}>
                        {Object.values(this.speakers).filter(c => this.isSpeakerInUi(c)).map((speaker, i) => (
                            <SpeakerButton
                                key={`character_options_${speaker.anonymizedId}`}
                                speaker={speaker}
                                stage={this}
                                borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}
                                onOpenSettings={(sp) => this.speakerSettingsHandle?.setSpeaker(sp)}
                            />
                        ))}
                    </div>
                    <BackgroundImage imageUrl={this.messageState.backgroundUrl} borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}/>
                    <AnimatePresence>
                        {Object.values(this.speakers).map(character => {
                            if (this.isSpeakerDisplayed(character)) {
                                index++;
                                const xPosition = count == 1 ? 50 :
                                    ((index % 2 == 1) ?
                                        (Math.ceil(index / 2) * (50 / (Math.ceil(count / 2) + 1))) :
                                        (Math.floor(index / 2) * (50 / (Math.floor(count / 2) + 1)) + 50));
                                // Farther from 50, higher up on the screen:
                                const yPosition = Math.ceil(Math.abs(xPosition - 50) / 5);
                                // Closer to 50, higher visual priority:
                                const zIndex = Math.ceil((50 - Math.abs(xPosition - 50)) / 5);

                                return <SpeakerImage
                                    key={`character_${character.anonymizedId}`}
                                    speaker={character}
                                    emotion={this.getSpeakerEmotion(character.anonymizedId)}
                                    xPosition={xPosition}
                                    yPosition={yPosition}
                                    zIndex={zIndex}
                                    imageUrl={this.getSpeakerImage(character.anonymizedId, this.chatState.selectedOutfit[character.anonymizedId], this.getSpeakerEmotion(character.anonymizedId), '')}
                                    isTalking={this.messageState.activeSpeaker == character.anonymizedId}
                                />
                            } else {
                                return <></>
                            }
                        })}
                    </AnimatePresence>
                </ThemeProvider>
            </div>

        );
    }

}
