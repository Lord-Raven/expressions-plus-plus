import {
    StageBase,
    StageResponse,
    InitialData,
    Message,
    AspectRatio,
    Speaker,
    Character
} from "@chub-ai/stages-ts";
import {LoadResponse} from "@chub-ai/stages-ts/dist/types/load";
import { Client } from "@gradio/client";
import {ReactElement} from "react";
import Scene from "./Scene.tsx";
import SpeakerButton from "./SpeakerButton.tsx";
import BackgroundButton from "./BackgroundButton.tsx";
import {createTheme, ThemeProvider} from "@mui/material";
import {MessageQueue, MessageQueueHandle} from "./MessageQueue.tsx";
import {FastAverageColor} from "fast-average-color";
import SpeakerSettings, {SpeakerSettingsHandle} from "./SpeakerSettings.tsx";
import NewSpeakerSettings from "./NewSpeakerSettings.tsx";
import ColorThief from "colorthief";
import { Emotion, EMOTION_MAPPING, EMOTION_PROMPTS, EmotionPack } from "./Emotion.tsx";
import { Background, DEFAULT_BORDER_COLOR, DEFAULT_HIGHLIGHT_COLOR, BACKGROUND_ART_PROMPT } from "./Background.tsx";
import BackgroundSettings, { BackgroundSettingsHandle } from "./BackgroundSettings.tsx";



type ChatStateType = {
    generatedWardrobes:{[key: string]: {[key: string]: EmotionPack}};
    selectedOutfit:{[key: string]: string};
    generatedDescriptions:{[key: string]: string};
    speakerVisible:{[key: string]: boolean};
    backgrounds:{[key: string]: Background};
    selectedBackground: string;
}

type OutfitType = {
    // A name for the outfit
    name: string;
    // Description generated by the AI, used for generating the image
    artPrompt: string;
    // Images for the outfit, keyed by emotion
    images: EmotionPack;
    // Comma-delimitted list of trigger words that will swap to this outfit
    triggerWords: string;
    // Whether this outfit was generated by this stage or managed by a built-in emotion pack
    generated: boolean;
    // Whether this outfit is saved locally or globally
    global: boolean;
}

type WardrobeType = {
    speakerId: string;
    outfits: {[key: string]: OutfitType};
}

type ConfigType = {
    artStyle?: string;
    generateCharacters?: string;
    generateBackgrounds?: string;
    selected?: {[key: string]: string} | null;
    alphaMode?: string;
    useBackgroundDepth?: boolean;
};

type InitStateType = null;

type MessageStateType = {
    backgroundUrl: string;
    depthUrl: string;
    borderColor: string;
    highlightColor: string;
    speakerEmotion: {[key: string]: string};
    activeSpeaker: string;
};

const darkTheme = createTheme({
    palette: {
        mode: 'dark',
        background: {
            default: '#121212',
            paper: '#1e1e1e',
        },
        text: {
            primary: '#ffffff',
            secondary: '#aaaaaa',
        }
    },
});

const CHARACTER_ART_PROMPT: string = 'plain flat background, standing, full body, head-to-toe';
const CHARACTER_NEGATIVE_PROMPT: string = 'border, ((close-up)), scenery, special effects, scene, dynamic angle, action, cut-off';

export const DEFAULT_OUTFIT_NAME: string = 'Starter Outfit';

// Replace trigger words with less triggering words, so image gen can succeed.
export function substitute(input: string) {
    const synonyms: [string, string][] = [
        ['old-school', 'retro'],
        ['old school', 'retro'],
        ['oldschool', 'retro'],
        ['schoolgirl', 'college girl'],
        ['school girl', 'college girl'],
        ['schoolboy', 'college guy'],
        ['school boy', 'college guy'],
        ['schoolteacher', 'professor'],
        ['school teacher', 'professor'],
        ['school', 'college'],
        ['youngster', 'individual'],
        ['child', 'individual'],
        ['kid', 'individual'],
        ['young', 'youthful']
    ];

    for (const [key, replacement] of synonyms) {
        const regex = new RegExp(key, 'gi');
        input = input.replace(regex, (match) => {
            return match[0] === match[0].toUpperCase()
                ? replacement.charAt(0).toUpperCase() + replacement.slice(1)
                : replacement;
        });
    }

    return input;
}

export function generateGuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {
        const random = (Math.random() * 16) | 0;
        const value = char === 'x' ? random : (random & 0x3) | 0x8;
        return value.toString(16);
    });
}

export class Expressions extends StageBase<InitStateType, ChatStateType, MessageStateType, ConfigType> {

    // Chat state:
    chatState: ChatStateType;

    // Message state:
    messageState: MessageStateType;

    // Saved to storage
    wardrobes: {[key: string]: WardrobeType} = {};
    // This is used for comparison versus storage wardrobes to determine if storage has changed outside this instance of the stage,
    // so that those changes can be reconciled against a potentially modified wardrobes above.
    // Should be set after a successful load/reconciliation.
    backupWardrobes: {[key: string]: WardrobeType} = {};

    // Not saved:
    emotionPipeline: any = null;
    zeroShotPipeline: any = null;
    depthPipeline: any = null;
    generateCharacters: boolean;
    generateBackgrounds: boolean;
    useBackgroundDepth: boolean;
    artStyle: string;
    speakers: {[key: string]: Speaker};
    alphaMode: boolean;
    owns: string[] = []; // List of speakerIds that this client owns (generally themself and their owned characters).
    canEdit: string[] = []; // List of speakerIds that this client can edit (generally themself and any character).
    userId: string; // ID of this client

    readonly fac = new FastAverageColor();
    readonly colorThief = new ColorThief();
    private messageHandle?: MessageQueueHandle;
    private speakerSettingsHandle?: SpeakerSettingsHandle;
    private backgroundSettingsHandle?: BackgroundSettingsHandle;

    constructor(data: InitialData<InitStateType, ChatStateType, MessageStateType, ConfigType>) {
        super(data);
        const {
            characters,
            config,
            messageState,
            chatState,
            users,
            userId
        } = data;

        console.log(config);
        console.log(characters);
        console.log(users);

        this.userId = userId;
        this.owns = [userId];
        this.canEdit = [userId, ...Object.keys(characters)];
        this.speakers = {...characters, ...users};

        // Set states or default them.
        this.messageState = {
            backgroundUrl: messageState?.backgroundUrl ?? '',
            depthUrl: messageState?.depthUrl ?? '',
            borderColor: messageState?.borderColor ?? DEFAULT_BORDER_COLOR,
            highlightColor: messageState?.highlightColor ?? DEFAULT_HIGHLIGHT_COLOR,
            speakerEmotion: messageState?.speakerEmotion ?? {},
            activeSpeaker: messageState?.activeSpeaker ?? ''
        }

        this.chatState = {
            generatedWardrobes: chatState?.generatedWardrobes ?? {},
            selectedOutfit: chatState?.selectedOutfit ?? {},
            generatedDescriptions: chatState?.generatedDescriptions ?? {},
            speakerVisible: chatState?.speakerVisible ?? {},
            backgrounds: chatState?.backgrounds ?? {},
            selectedBackground: chatState?.selectedBackground ?? ''
        };

        this.generateCharacters = (config?.generateCharacters ?? "True") == "True";
        this.generateBackgrounds = (config?.generateBackgrounds ?? "True") == "True";
        this.useBackgroundDepth = (config?.useBackgroundDepth ?? "True") == "True";
        this.alphaMode = (config?.alphaMode ?? "False") == "True";
        this.artStyle = config?.artStyle ?? 'Bold, visual novel style illustration, clean lines';

        if (!this.alphaMode) {
            // Look at characters, set up packs, and initialize values that aren't present in message/chat state
            Object.keys(this.speakers).forEach((charAnonId: string) => {
                const speaker = this.speakers[charAnonId];
                if (!speaker.isRemoved) {
                    if (this.chatState.generatedWardrobes[charAnonId] && this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME] && Object.keys(this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME]).length > 0) {
                        console.log('Character has a wardrobe.');
                    } else {
                        console.log('Initializing a new wardrobe.')
                        this.chatState.generatedWardrobes[charAnonId] = {[DEFAULT_OUTFIT_NAME]: {}};
                        this.chatState.selectedOutfit[charAnonId] = DEFAULT_OUTFIT_NAME;
                    }
                }
            });
        }

        // Initialize default background if none exists
        if (Object.keys(this.chatState.backgrounds).length === 0) {
            const defaultBackgroundId = generateGuid();
            this.chatState.backgrounds[defaultBackgroundId] = {
                id: defaultBackgroundId,
                name: 'Default Background',
                artPrompt: '',
                backgroundUrl: this.messageState.backgroundUrl ?? '',
                depthUrl: this.messageState.depthUrl ?? '',
                borderColor: this.messageState.borderColor ?? DEFAULT_BORDER_COLOR,
                highlightColor: this.messageState.highlightColor ?? DEFAULT_HIGHLIGHT_COLOR,
                triggerWords: ''
            };
            this.chatState.selectedBackground = defaultBackgroundId;
            this.wrapPromise(this.generateBackgroundImage(Object.values(this.speakers)[0], this.chatState.backgrounds[defaultBackgroundId], ''), `Generating background for ${this.chatState.backgrounds[defaultBackgroundId].name}.`);
        }
    }

    async load(): Promise<Partial<LoadResponse<InitStateType, ChatStateType, MessageStateType>>> {
        await this.updateBackground();

        try {
            this.emotionPipeline = await Client.connect("ravenok/emotions");
            this.zeroShotPipeline = await Client.connect("ravenok/statosphere-backend");
            this.depthPipeline = await Client.connect("ravenok/Depth-Anything-V2");
        } catch (except: any) {
            console.error(`Error loading pipelines, error: ${except}`);
            return { success: false, error: except }
        }

        if (this.alphaMode) {
            console.warn('Alpha mode enabled. This is experimental and may break things.');

            
            // Test whether userId has storage access to update canonical character data and update owns accordingly
            for (const speakerId of Object.keys(this.speakers)) {
                if (this.isSpeakerIdCharacterId(speakerId)) {
                    try {
                        const response: any = await this.storage.set('dummy', {data: "dummy data"}).forCharacterSensitive(speakerId);
                        console.log(response);
                        if (response.errors) {
                            console.error(`Failed sensitive storage access for ${speakerId}: ${response.errors}`);
                        } else {
                            console.log(`Successfully accessed sensitive storage for ${speakerId}`);
                            this.owns.push(speakerId);
                        }
                    } catch (error) {
                        console.error(`Error accessing sensitive storage for ${speakerId}: ${error}`);
                    }
                }
            }

            // Load wardrobes from storage API:
            this.wardrobes = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
            console.log('Loaded wardrobes from storage:');
            console.log(this.wardrobes);
            this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));

            // Load expression pack wardrobes:
            for (let charAnonId of Object.keys(this.speakers)) {
                if ('partial_extensions' in this.speakers[charAnonId]) {
                    const character: Character = this.speakers[charAnonId] as Character;
                    if (character.partial_extensions?.chub?.expressions?.expressions != null) {
                        console.log(`Character ${charAnonId} has an expressions pack.`);
                        // Generate outfit entries for each expressions pack, marked non-generated.
                        if (!this.wardrobes[charAnonId]) {
                            this.wardrobes[charAnonId] = {
                                speakerId: charAnonId,
                                outfits: {}
                            };
                        }
                        for (let expressionPack of Object.values([character.partial_extensions.chub.expressions])) {
                            this.wardrobes[charAnonId].outfits[expressionPack.version] = {
                                images: expressionPack.expressions,
                                name: expressionPack.version,
                                triggerWords: '',
                                artPrompt: '',
                                generated: false,
                                global: false
                            };
                        }
                    }
                }
            }

            // Initialize wardrobes for characters with no loaded wardrobes
            
            for (let speakerId of Object.keys(this.speakers)) {
                if (!(speakerId in this.wardrobes) || this.wardrobes[speakerId].outfits == null || Object.keys(this.wardrobes[speakerId].outfits).length === 0) {
                    console.log(`Initializing wardrobe for ${speakerId}.`);
                    this.wardrobes[speakerId] = {
                        speakerId: speakerId,
                        outfits: {
                            [generateGuid()]: {
                                name: DEFAULT_OUTFIT_NAME,
                                artPrompt: '',
                                images: {},
                                triggerWords: '',
                                generated: true,
                                global: false
                            }
                        }
                    } as WardrobeType;
                }

                // Set a selected outfit if none exists.
                console.log(`Checking selectedOutfit for ${speakerId}: ${this.chatState.selectedOutfit[speakerId]}`);
                if (!this.chatState.selectedOutfit[speakerId] || this.chatState.selectedOutfit[speakerId] == '' || !(this.chatState.selectedOutfit[speakerId] in this.wardrobes[speakerId].outfits)) {
                    console.log(`Setting selectedOutfit for ${speakerId}.`);
                    this.chatState.selectedOutfit[speakerId] = Object.keys(this.wardrobes[speakerId].outfits)[0];
                }
            }
        }

        for (let speaker of Object.values(this.speakers)) {
            if (!(speaker.anonymizedId in this.chatState.speakerVisible)) {
                this.chatState.speakerVisible[speaker.anonymizedId] = !('chatProfile' in speaker);
                //this.singleSpeakerCheck(speaker).then(result => {this.chatState.speakerVisible[speaker.anonymizedId] = result; this.updateChatState()});
            }
        }

        return {
            success: true,
            chatState: this.chatState,
            messageState: this.messageState,
            error: null
        };
    }

    async updateBackground() {
        await this.updateChatState();
        await this.messenger.updateEnvironment({background: this.getSelectedBackground().backgroundUrl});
    }

    async setState(state: MessageStateType): Promise<void> {
        if (state != null) {
            this.messageState = {
                backgroundUrl: state?.backgroundUrl ?? '',
                depthUrl: state?.depthUrl ?? '',
                borderColor: state?.borderColor ?? DEFAULT_BORDER_COLOR,
                highlightColor: state?.highlightColor ?? DEFAULT_HIGHLIGHT_COLOR,
                speakerEmotion: state?.speakerEmotion ?? {},
                activeSpeaker: state?.activeSpeaker ?? ''
            }
            await this.updateBackground();
        }
    }

    async updateEmotion(speaker: Speaker, content: string) {
        let newEmotion = 'neutral';
        if (this.emotionPipeline != null) {
            try {
                const emotionResult = (await this.emotionPipeline.predict("/predict", {
                    param_0: content,
                }))
                console.log(`Emotion result: `);
                console.log(emotionResult.data[0].confidences);
                newEmotion = emotionResult.data[0].confidences.find((confidence: {label: string, score: number}) => confidence.label != 'neutral' && confidence.score > 0.1)?.label ?? newEmotion;
            } catch (except: any) {
                console.warn(`Error classifying expression, error: ${except}`);
                newEmotion = this.fallbackClassify(content);
            }
        } else {
            newEmotion = this.fallbackClassify(content);
        }
        console.info(`New emotion for ${speaker.name}: ${newEmotion}`);
        this.messageState.speakerEmotion[speaker.anonymizedId] = newEmotion;
        this.messageState.activeSpeaker = speaker.anonymizedId;
        if ((this.alphaMode && !this.wardrobes[speaker.anonymizedId].outfits[this.chatState.selectedOutfit[speaker.anonymizedId]]?.images[EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion]) ||
            (!this.alphaMode && !this.chatState.generatedWardrobes[speaker.anonymizedId][this.chatState.selectedOutfit[speaker.anonymizedId]][EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion])) {
            this.wrapPromise(
                this.generateSpeakerImage(speaker, this.chatState.selectedOutfit[speaker.anonymizedId], EMOTION_MAPPING[newEmotion as Emotion] ?? (newEmotion as Emotion)),
                `Generating ${newEmotion} for ${speaker.name} (${this.chatState.selectedOutfit[speaker.anonymizedId]}).`);
        }
    }

    async beforePrompt(userMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[userMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[userMessage.anonymizedId], userMessage.content);
        }
        // await this.backgroundCheck(userMessage.content);
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    fallbackClassify(text: string): string {
        const lowered = text.toLowerCase();
        let result = 'neutral';
        Object.values(Emotion).forEach(emotion => {
            if(lowered.includes(emotion.toLowerCase())) {
                result = emotion;
            }
        });
        return result;
    }

    async afterResponse(botMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[botMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[botMessage.anonymizedId], botMessage.content);
        }

        // await this.backgroundCheck(botMessage.content);

        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    async wrapPromise(promise: Promise<void>|null, message: string): Promise<void> {
        if (!promise) {
            promise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve(void 0);
                }, 3000);
            });
        }
        if (this.messageHandle) {
            this.messageHandle.addLoadingMessage(promise, message);
        }
        return promise;
    }

    pickOutfits(speakerId: string, test: (outfit: OutfitType) => boolean): WardrobeType {
        const wardrobe = this.wardrobes[speakerId];
        return wardrobe ? {
            speakerId: speakerId,
            outfits: Object.keys(wardrobe.outfits).reduce((acc: {[key: string]: OutfitType}, outfitKey: string) => {
                if (wardrobe.outfits[outfitKey] && test(wardrobe.outfits[outfitKey])) {
                    acc[outfitKey] = wardrobe.outfits[outfitKey];
                }
                return acc;
            }, {})
        } : {
            speakerId: speakerId,
            outfits: {}
        };
    }

    async readCharacterWardrobesFromStorage(speakerIds: string[]): Promise<{[key: string]: WardrobeType}> {
        // A speakerId is either a character ID or a persona ID.
        // A speakerId can have both per-chat and global wardrobes that need to be loaded and combined.


        const wardrobeFetches = [
            // TODO: get() needs a forChat()
            this.storage.query(
                {
                    keys: ['local_wardrobe'],
                    chat_local: true,
                    character_ids: speakerIds.filter(id => this.isSpeakerIdCharacterId(id))
                }),
            this.storage.query(
                {
                    keys: ['local_wardrobe'],
                    chat_local: true,
                    character_ids: speakerIds.filter(id => !this.isSpeakerIdCharacterId(id)),
                    user_ids: speakerIds.filter(id => !this.isSpeakerIdCharacterId(id))
                }),
            this.storage.get('global_wardrobe').forCharacters(speakerIds.filter(id => this.isSpeakerIdCharacterId(id))),
            this.storage.get('global_wardrobe').forUsers(speakerIds.filter(id => !this.isSpeakerIdCharacterId(id))),
        ];

        // Load all wardrobes in parallel
        console.log('All fetched wardrobes:');
        const allWardrobes = await Promise.all(wardrobeFetches.map(async promise => {const response = await promise; console.log(response); return response}));

        const finalWardrobes = allWardrobes.map(response => response.data).flat().filter(item => item.character_id).reduce((acc: {[key: string]: WardrobeType}, item) => {
            // Combine the wardrobes
            const key = item.character_id ?? '';
            const value = item.value as WardrobeType;
            acc[key] = acc[key] ? {...acc[key], outfits: {...acc[key].outfits, ...value.outfits } } : value;
            return acc;
        }, {});

        console.log('Final, assembled wardrobes:');
        console.log(finalWardrobes);

        return finalWardrobes;
    }

    async updateStorage() {
        if (this.alphaMode) {

            const remoteWardrobes: {[key: string]: WardrobeType} = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
            // Should check for differences in wardrobes between existingWardrobes and this.backupWardrobes, then apply non-conflicting changes to this.wardrobes before saving.
            // Bear in mind that this.backupWardrobes will have non-generated outfits, while we expect existingWardrobes to have only generated outfits.
            console.log('Existing wardrobes from storage:');
            console.log(remoteWardrobes);
            // Compare existingWardrobes against this.backupWardrobes to find differences in generated outfits:
            Object.keys(remoteWardrobes).forEach((speakerId) => {
                if (this.backupWardrobes[speakerId]) {
                    for (let outfitKey of Object.keys(remoteWardrobes[speakerId].outfits)) {
                        // If the outfit exists in existingWardrobes but not in backup, it means it was added by another user
                        // We need to add it to this.wardrobes.
                        if (!this.backupWardrobes[speakerId].outfits[outfitKey] && Object.keys(remoteWardrobes[speakerId].outfits[outfitKey].images).length > 0) {
                            console.log(`Outfit ${outfitKey} was added for ${speakerId}`);
                            this.wardrobes[speakerId].outfits[outfitKey] = remoteWardrobes[speakerId].outfits[outfitKey];
                        } else if (this.backupWardrobes[speakerId].outfits[outfitKey] && !this.wardrobes[speakerId].outfits[outfitKey]) {
                            // If the outfit exists in backup but not in this.wardrobes, it means it was removed locally.
                            console.log(`Outfit ${outfitKey} was removed for ${speakerId}`);
                            // No action is taken; the deletion will be pushed below.
                        } else {
                            // If the outfit exists in both existingWardrobes and backup, we need to compare images to see if any need to be updated.
                            // Be smart about this; some images may have been updated in this.wardrobes. We only want to apply differences and not all images.
                            console.log(`Outfit ${outfitKey} exists in both existing and backup wardrobes for ${speakerId}. Checking images...`);

                            const existingImages = remoteWardrobes[speakerId].outfits[outfitKey].images || {};
                            const backupImages = this.backupWardrobes[speakerId].outfits[outfitKey].images || {};
                            const currentImages = this.wardrobes[speakerId].outfits[outfitKey].images || {};
                            
                            // Compare each emotion/image key
                            Object.keys(existingImages).forEach((emotionKey) => {
                                const existingImageUrl = existingImages[emotionKey];
                                const backupImageUrl = backupImages[emotionKey];
                                
                                // If the image exists in existing but not in backup, it was added externally
                                if (existingImageUrl && !backupImageUrl) {
                                    console.log(`Image for emotion '${emotionKey}' was added externally for ${speakerId}/${outfitKey}`);
                                    this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                                }
                                // If the image exists in both but has different URLs, it was updated externally
                                else if (existingImageUrl && backupImageUrl && existingImageUrl !== backupImageUrl) {
                                    // Only apply if we haven't locally modified this image since backup
                                    if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImageUrl) {
                                        console.log(`Image for emotion '${emotionKey}' was updated externally for ${speakerId}/${outfitKey}`);
                                        this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                                    } else {
                                        console.log(`Image for emotion '${emotionKey}' has conflicting changes - keeping local version for ${speakerId}/${outfitKey}`);
                                    }
                                }
                            });
                            
                            // Check for images that were removed externally
                            Object.keys(backupImages).forEach((emotionKey) => {
                                if (backupImages[emotionKey] && !existingImages[emotionKey]) {
                                    // Only remove if we haven't locally modified this image since backup
                                    if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImages[emotionKey]) {
                                        console.log(`Image for emotion '${emotionKey}' was removed externally for ${speakerId}/${outfitKey}`);
                                        delete this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey];
                                    } else {
                                        console.log(`Image for emotion '${emotionKey}' was removed externally but has local changes - keeping local version for ${speakerId}/${outfitKey}`);
                                    }
                                }
                            });

                            // Check for outfit name, generatedDescription, and triggerWords:
                            if (remoteWardrobes[speakerId].outfits[outfitKey].name && 
                                this.wardrobes[speakerId].outfits[outfitKey].name !== remoteWardrobes[speakerId].outfits[outfitKey].name && 
                                this.wardrobes[speakerId].outfits[outfitKey].name == this.backupWardrobes[speakerId].outfits[outfitKey].name) {
                                console.log(`Outfit name changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].name}' to '${remoteWardrobes[speakerId].outfits[outfitKey].name}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].name = remoteWardrobes[speakerId].outfits[outfitKey].name;
                            }
                            if (remoteWardrobes[speakerId].outfits[outfitKey].artPrompt && 
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt !== remoteWardrobes[speakerId].outfits[outfitKey].artPrompt &&
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt == this.backupWardrobes[speakerId].outfits[outfitKey].artPrompt) {
                                console.log(`Outfit description changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].artPrompt}' to '${remoteWardrobes[speakerId].outfits[outfitKey].artPrompt}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt = remoteWardrobes[speakerId].outfits[outfitKey].artPrompt;
                            }
                            if (remoteWardrobes[speakerId].outfits[outfitKey].triggerWords && 
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords !== remoteWardrobes[speakerId].outfits[outfitKey].triggerWords &&
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords == this.backupWardrobes[speakerId].outfits[outfitKey].triggerWords) {
                                console.log(`Outfit trigger words changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].triggerWords}' to '${remoteWardrobes[speakerId].outfits[outfitKey].triggerWords}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords = remoteWardrobes[speakerId].outfits[outfitKey].triggerWords;
                            }
                        }
                    }
                    // Compare outfits:
                    Object.keys(this.backupWardrobes[speakerId].outfits).forEach((outfitName) => {
                        if (this.backupWardrobes[speakerId].outfits[outfitName] && !remoteWardrobes[speakerId].outfits[outfitName]) {
                            // If the outfit exists in backup but not in existing, it means it was removed
                            console.log(`Outfit ${outfitName} was removed for ${speakerId}`);
                        }
                    });
                }
            });

            // Push current wardrobes
            console.log('Pushing wardrobe updates to storage.');

            // Build updates for this persona's stuff:
            let updateBuilder = this.storage.set('local_wardrobe', this.pickOutfits(this.userId, outfit => outfit.generated && !outfit.global)).forCharacter(this.userId).forUser().forChat()
                    .set('global_wardrobe', this.pickOutfits(this.userId, outfit => outfit.generated && outfit.global)).forCharacter(this.userId).forUser();

            // Add updates for editable or owned characters:
            for (let speakerId of Object.keys(this.wardrobes)) {
                if (this.wardrobes[speakerId] && this.wardrobes[speakerId].outfits) {
                    if (this.isSpeakerIdCharacterId(speakerId)) {
                        if (this.canEdit.includes(speakerId)) {
                            updateBuilder = updateBuilder.set('local_wardrobe', this.pickOutfits(speakerId, outfit => outfit.generated && !outfit.global)).forCharacter(speakerId).forChat();
                        }
                        if (this.owns.includes(speakerId)) {
                            updateBuilder = updateBuilder.set('global_wardrobe', this.pickOutfits(speakerId, outfit => outfit.generated && outfit.global)).forCharacter(speakerId);
                        }
                    }
                }
            }

            // Need to await all wardrobePromises, but also want to log their results
            const response = await updateBuilder;
            console.log(response);

            // With everything reconciled and updated, set backup to a copy of wardrobes.
            console.log('update backupWardrobes');
            this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));
        }

    }

    async updateChatState() {
        await this.messenger.updateChatState(this.chatState);
    }

    buildArtPrompt(speaker: Speaker, outfit: string, emotion: Emotion): string {
        let generatedDescription = '';
        if (this.alphaMode) {
            generatedDescription = this.wardrobes[speaker.anonymizedId]?.outfits?.[outfit]?.artPrompt ?? '';
        } else {
            generatedDescription = this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`] ?? '';
        }
        if (generatedDescription) {
            return `(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`]}), ((${CHARACTER_ART_PROMPT})), (${EMOTION_PROMPTS[emotion]})`;
        }
        return `No art prompt yet available for ${speaker.name} (${outfit}). Enter a custom prompt below or leave it blank to have the LLM craft an art prompt from context.`;
    }

    async generateSpeakerImagePrompt(speaker: Speaker, outfitKey: string): Promise<void> {
        // Must first build a visual description for this character:
        console.log(`Generating a physical description of ${speaker.name}.`);
        const outfitName = this.alphaMode ? this.wardrobes[speaker.anonymizedId].outfits[outfitKey].name : outfitKey;
        const imageDescription = await this.generator.textGen({
            prompt:
                `Chat History:\n{{messages}}\n\n` +
                (outfitName != DEFAULT_OUTFIT_NAME ? `New Outfit:\n${outfitName}\n\n` : '') +
                `Information about ${speaker.name}:\n${this.getSpeakerDescription(speaker)}\n\n` +
                `Instruction:\nThe goal of this request is to digest the information about ${speaker.name} and construct a simple, comprehensive, and functional visual description of ${speaker.name}. ` +
                `The chat history may involve other characters, but this system response will fixate on ${speaker.name}, forsaking other characters or background details. ` +
                `The result will be fed directly into an image generator, which is unfamiliar with this character, ` +
                `so use concise tags and keywords to convey all essential visual details about them, ` +
                `presenting ample and exhaustive character appearance notes--particularly if they seem obvious: gender, race, skin tone, hair do/color, physique, body shape, outfit, fashion, setting/theme, style, etc. ` +
                (outfitName != DEFAULT_OUTFIT_NAME ?
                    `Describe and emphasize that ${speaker.name} is wearing this prescribed outfit or vibe: ${outfitName}. Develop authentic visual details for the outfit. Aside from that, ` :
                    `Chat history is provided for potential context on ${speaker.name}'s current look; `) +
                `focus on persistent physical details over fleeting ones as this description will be applied to a variety of situations. Output the final visual description below.\n\n` +

                `Sample Response:\nWoman, tall, youthful, dark flowing hair, dark brown hair, loose wavy hair, tanned skin, muscular, modern clothes, worn jeans, dark red bomber jacket, dark brown eyes, thin lips, red and white running shoes, white tanktop.\n\n` +
                `Sample Response:\nMan in a billowing tattered cloak, Medieval fantasy, sinister appearance, dark hair, middle-aged, hair graying at temples, sallow face, elaborate wooden staff, green gem in staff, dark robes with green highlights.\n\n` +
                `Sample Response:\nA willowy androgynous figure, short spiky hair, pale skin, wearing a sleek black bodysuit with silver accents, futuristic cyberpunk style, glowing blue tattoos on arms, piercing blue eyes.\n\n` +
                '',
            min_tokens: 50,
            max_tokens: 140,
            include_history: true
        });
        if (imageDescription?.result) {
            console.log(`Received an image description: ${imageDescription.result}`);
            this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`] = imageDescription.result;
            if (this.alphaMode && this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].artPrompt = imageDescription.result;
            }
            await this.updateChatState();
        } else {
            return;
        }
    }

    async generateSpeakerImage(speaker: Speaker, outfitKey: string, emotion: Emotion): Promise<void> {
        console.log(`Current generated descriptions: ${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`]} and ${this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]?.artPrompt}`);
        const outfitName = this.alphaMode ? (this.wardrobes[speaker.anonymizedId].outfits[outfitKey]?.name ?? outfitKey) : outfitKey;

        if (!this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`] || (this.alphaMode && !this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]?.artPrompt)) {
            await this.generateSpeakerImagePrompt(speaker, outfitKey);
        }

        // Must do neutral first:
        if (emotion != Emotion.neutral && !this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral]) {
            emotion = Emotion.neutral;
        }
        console.log(`Generating ${emotion} image for ${speaker.name} (${outfitName}).`)
        if (emotion == Emotion.neutral) {
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(this.buildArtPrompt(speaker, outfitKey, emotion)),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            // Clear entire pack then assign this image:
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey] = {};
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral] = imageUrl;
            if (this.alphaMode) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images = {};
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral] = imageUrl;
            }
            /*if (!this.generating) {
                this.generateNextImage(0);
            }*/
        } else {
            const imageUrl = (await this.generator.imageToImage({
                image: this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral],
                prompt: substitute(`(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`]}), (${CHARACTER_ART_PROMPT}), ((Strong Emotion: ${EMOTION_PROMPTS[emotion]}))`),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true,
                strength: 0.1
            }))?.url ?? this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral] ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][emotion] = imageUrl;
            if (this.alphaMode) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[emotion] = imageUrl;
            }
        }
        await this.updateChatState();
    }

    async backgroundCheck(content: string): Promise<void> {
        // Repurpose this for triggering background swaps to known backgrounds based on key words
        /*if (this.flagBackground || !this.generateBackgrounds || !content) return;

        if (this.messageState.backgroundUrl) {
            const TRANSITION_LABEL = 'transitions to a new location';
            const STAY_LABEL = 'does not alter the location or setting';
            try {
                const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                        sequence: content,
                        candidate_labels: [STAY_LABEL, TRANSITION_LABEL],
                        hypothesis_template: 'This passage {}.',
                        multi_label: true
                    })});
                const result = JSON.parse(`${response.data[0]}`);
                console.log('Zero-shot result:');
                console.log(result);
                if (result.labels[0] == STAY_LABEL || result.scores[0] < 0.5) {
                    return;
                }
            } catch (except) {
                console.warn(except);
                return;
            }
        }

        this.flagBackground = true;*/
    }

    async generateBackgroundImage(character: Speaker, background: Background, content: string): Promise<void> {
        // Must first build a visual description for the background
        if (!this.generateBackgrounds) return;
        if (!background.artPrompt) {
            console.log(`Generate a description of the background.`);
            const imageDescription = await this.generator.textGen({
                prompt:
                    ((character && 'personality' in character) ? `Information about ${character.name}, for Flavor:\n${character.personality}` : '') +
                    `Chat History:\n{{messages}}\n\n` +
                    `Current Instruction:\nThe goal of this task is to digest the flavor text and chat history to construct a comprehensive and concise visual description of ` +
                        (content ? `this background scenery: ${content}.` : `the current scenery. `) +
                    `This system response will be fed directly into an image generator, which is unfamiliar with the setting; ` +
                    `use tags and keywords to convey all essential details about the location, ambiance, weather, or time of day (as applicable), ` +
                    `presenting ample appearance notes. Fixate on the visual details of the surroundings, ignoring action or characters.\n\n` +
                    `Sample Response:\nDesolate wasteland, sandy, oppressively bright, glare, cracked earth, forlorn crags.\n\n` +
                    `Sample Response:\nSmall-town America, charming street, quaint houses, alluring shopfronts, crisp fall foliage.\n\n` +
                    `Sample Response:\nCramped sci-fi hallway, dim emergency lighting, aboard a space station, haunting shapes, loose ducts.\n\n` +
                    `Sample Response:\nForgotten ruins, mossy worn stonework, dense forest, swampy surroundings, entrance leading deep into the unknown, pervasive mist.`,
                min_tokens: 50,
                max_tokens: 150,
                include_history: true
            });
            if (imageDescription?.result) {
                console.log(`Received an image description: ${imageDescription.result}. Generating a background.`);
                background.artPrompt = imageDescription.result;
            }
        }
        if (!background.artPrompt) {
            // Display error message about failed art prompt:
            console.warn(`Failed to generate a background description. Cannot generate background image.`);
            return;
        }
        const imageUrl = (await this.generator.makeImage({
            prompt: substitute(`(Art style: ${this.artStyle}), (${BACKGROUND_ART_PROMPT}), (${background.artPrompt})`),
            aspect_ratio: AspectRatio.CINEMATIC_HORIZONTAL,
        }))?.url ?? '';
        if (imageUrl == '') {
            console.warn(`Failed to generate a background image.`);
        } else {
            background.backgroundUrl = imageUrl;
            if (this.alphaMode && this.useBackgroundDepth) {
                try {
                    // This endpoint takes actual image data and not a URL; need to load data from imageUrl
                    const response = await fetch(imageUrl);
                    const imageBlob = await response.blob();
                    const depthPromise = this.depthPipeline.predict("/on_submit", {image: imageBlob});

                    // Need to get a HtmlImageElement for getPalette:
                    const imageElement = document.createElement('img');
                    imageElement.src = URL.createObjectURL(imageBlob);
                    // Wait for the image to load before calling getPalette
                    await new Promise((resolve) => {
                        imageElement.onload = resolve;
                    });

                    // Get colors and sort by "brightness"; map to CSS hex color from rgb
                    const colors = this.colorThief.getPalette(imageElement, 10).sort((a, b) => {
                        const brightnessA = a[0] * 0.299 + a[1] * 0.587 + a[2] * 0.114;
                        const brightnessB = b[0] * 0.299 + b[1] * 0.587 + b[2] * 0.114;
                        return brightnessB - brightnessA;
                    }).map(c => `#${c.map(channel => channel.toString(16).padStart(2, '0')).join('')}`);

                    console.log(`Color palette: ${colors}`);

                    background.highlightColor = colors[0];
                    background.borderColor = colors[Math.floor(colors.length / 2)];
                    background.depthUrl = '';
                    const depthResponse = await depthPromise;
                    console.log(depthResponse);
                    background.depthUrl = depthResponse.data[1].url;
                } catch (err) {
                    console.warn(`Failed to generate palette or depth map for background image: ${err}`);
                }
            }
        }

        await this.updateBackground();
    }

    async singleSpeakerCheck(speaker: Speaker) {
        const SINGLE_CHARACTER_LABEL = `a character named ${speaker.name}`;
        const MULTI_CHARACTER_LABEL = `multiple characters named ${speaker.name}`;
        const NARRATOR_LABEL = 'a narrator, setting, or scenario';
        try {
            const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                    sequence: `Name: ${speaker.name}\nDescription: ${this.getSpeakerDescription(speaker)}`,
                    candidate_labels: [SINGLE_CHARACTER_LABEL, MULTI_CHARACTER_LABEL, NARRATOR_LABEL],
                    hypothesis_template: `The focus is {}.`,
                    multi_label: true
                })});
            const result = JSON.parse(`${response.data[0]}`);
            console.log('Zero-shot result:');
            console.log(result);
            if (result.labels && result.labels[0] != SINGLE_CHARACTER_LABEL) {
                console.log(`${speaker.name} determined to be non-solo character.`);
                return false;
            }
        } catch (except) {
            console.warn(except);
        }
        return true;
    }

    isSpeakerIdCharacterId(speakerId: string): boolean {
        return this.isSpeakerCharacter(this.speakers[speakerId]);
    }

    isSpeakerCharacter(speaker: Speaker): boolean {
        return speaker && 'personality' in speaker;
    }

    getSpeakerDescription(speaker: Speaker) {
        return 'personality' in speaker ? speaker.personality : ('chatProfile' in speaker ? speaker.chatProfile : '');
    }

    getSpeakerEmotion(anonymizedId: string): Emotion {
        return this.messageState.speakerEmotion[anonymizedId] as Emotion ?? Emotion.neutral;
    }

    getSpeakerImage(anonymizedId: string, outfit: string, emotion: Emotion, defaultUrl: string): string {
        if (this.alphaMode) {
            return this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[EMOTION_MAPPING[emotion] ?? emotion] ?? this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[Emotion.neutral] ?? defaultUrl;
        }
        return this.chatState.generatedWardrobes[anonymizedId][(outfit && outfit in this.chatState.generatedWardrobes[anonymizedId]) ? outfit : DEFAULT_OUTFIT_NAME][EMOTION_MAPPING[emotion] ?? emotion] ?? this.chatState.generatedWardrobes[anonymizedId][outfit][Emotion.neutral] ?? defaultUrl;
    }

    isSpeakerInUi(speaker: Speaker) {
        return !speaker.isRemoved;
    }
    isSpeakerActive(speaker: Speaker) {
        return speaker.anonymizedId == this.messageState.activeSpeaker
    }
    isSpeakerVisible(speaker: Speaker) {
        // Characters default to true, Users to false
        return this.chatState.speakerVisible[speaker.anonymizedId] ?? ('personality' in speaker);
    }
    isSpeakerDisplayed(speaker: Speaker) {
        return this.isSpeakerActive(speaker) || (this.isSpeakerInUi(speaker) && this.isSpeakerVisible(speaker));
    }

    getSelectedBackground(): Background {
        return this.chatState.backgrounds[this.chatState.selectedBackground] || {
            id: '',
            name: 'Default Background',
            artPrompt: '',
            backgroundUrl: '',
            depthUrl: '',
            borderColor: DEFAULT_BORDER_COLOR,
            highlightColor: DEFAULT_HIGHLIGHT_COLOR,
            triggerWords: ''
        };
    }

    async setSelectedBackground(backgroundId: string): Promise<void> {
        if (this.chatState.backgrounds[backgroundId]) {
            this.chatState.selectedBackground = backgroundId;
            
            await this.updateBackground();
            await this.updateChatState();
        }
    }
    
    createNewBackground(name: string = 'New Background'): Background {
        const backgroundId = generateGuid();
        return {
            id: backgroundId,
            name: name,
            artPrompt: '',
            backgroundUrl: '',
            depthUrl: '',
            borderColor: DEFAULT_BORDER_COLOR,
            highlightColor: DEFAULT_HIGHLIGHT_COLOR,
            triggerWords: ''
        };
    }

    render(): ReactElement {

        return(
            <div className="big-stacker"
                key={'big-over-stacker'}
                style={{
                    width: '100vw',
                    height: '100vh',
                    position: 'relative',
                    alignItems: 'stretch',
                    overflow: 'hidden'
                }}
            >
                <ThemeProvider theme={darkTheme}>
                    {this.alphaMode ? (
                        <NewSpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${this.wardrobes[char.anonymizedId].outfits[outfit].name}).`);
                            }}
                            />) : (
                        <SpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${outfit}).`);
                            }}
                        />)
                    }
                    <BackgroundSettings
                        register={(handle) => {this.backgroundSettingsHandle = handle;}}
                        stage={this}
                        borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                        onRegenerate={(background) => {
                            this.wrapPromise(this.generateBackgroundImage(Object.values(this.speakers)[0], background, background.name), `Generating background for ${background.name}.`);
                        }}
                    />
                    <MessageQueue register={(handle) => {this.messageHandle = handle;}} borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}/>
                    {/* Regenerate buttons for each character */}
                    <div style={{display: "flex", flexDirection: "column", gap: 10, alignItems: "end"}}>
                        {Object.values(this.speakers).filter(c => this.isSpeakerInUi(c)).map((speaker, i) => (
                            <SpeakerButton
                                key={`character_options_${speaker.anonymizedId}`}
                                speaker={speaker}
                                stage={this}
                                borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                                onOpenSettings={(sp) => this.speakerSettingsHandle?.setSpeaker(sp)}
                            />
                        ))}
                        {/* Background button */}
                        <BackgroundButton
                            key="background_options"
                            stage={this}
                            borderColor={this.getSelectedBackground().borderColor ?? DEFAULT_BORDER_COLOR}
                            onOpenSettings={(bg) => this.backgroundSettingsHandle?.setOpen(true)}
                        />
                    </div>
                    <Scene imageUrl={this.getSelectedBackground().backgroundUrl} depthUrl={this.getSelectedBackground().depthUrl} stage={this}/>
                </ThemeProvider>
            </div>

        );
    }

}
