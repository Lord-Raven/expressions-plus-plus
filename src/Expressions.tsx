import {
    StageBase,
    StageResponse,
    InitialData,
    Message,
    AspectRatio,
    Speaker,
    Character
} from "@chub-ai/stages-ts";
import {LoadResponse} from "@chub-ai/stages-ts/dist/types/load";
import { Client } from "@gradio/client";
import SpeakerImage from "./SpeakerImage.tsx";
import {ReactElement} from "react";
import BackgroundImage from "./BackgroundImage";
import SpeakerButton from "./SpeakerButton.tsx";
import {createTheme, ThemeProvider} from "@mui/material";
import {MessageQueue, MessageQueueHandle} from "./MessageQueue.tsx";
import {FastAverageColor} from "fast-average-color";
import { AnimatePresence } from "framer-motion";
import SpeakerSettings, {SpeakerSettingsHandle} from "./SpeakerSettings.tsx";
import NewSpeakerSettings from "./NewSpeakerSettings.tsx";
import ColorThief from "colorthief";

type ChatStateType = {
    generatedWardrobes:{[key: string]: {[key: string]: EmotionPack}};
    selectedOutfit:{[key: string]: string};
    generatedDescriptions:{[key: string]: string};
    speakerVisible:{[key: string]: boolean};
}

type OutfitType = {
    // A name for the outfit
    name: string;
    // Description generated by the AI, used for generating the image
    artPrompt: string;
    // Images for the outfit, keyed by emotion
    images: EmotionPack;
    // Comma-delimitted list of trigger words that will swap to this outfit
    triggerWords: string;
    // Whether this outfit was generated by this stage or managed by a built-in emotion pack
    generated: boolean;
}

type WardrobeType = {
    speakerId: string;
    outfits: {[key: string]: OutfitType};
}

type ConfigType = {
    artStyle?: string;
    generateCharacters?: string;
    generateBackgrounds?: string;
    selected?: {[key: string]: string} | null;
    alphaMode?: string;
};

type InitStateType = null;

type MessageStateType = {
    backgroundUrl: string;
    depthUrl: string;
    borderColor: string;
    speakerEmotion: {[key: string]: string};
    activeSpeaker: string;
};

export enum Emotion {
    neutral = 'neutral',
    admiration = 'admiration',
    amusement = 'amusement',
    anger = 'anger',
    annoyance = 'annoyance',
    approval = 'approval',
    caring = 'caring',
    confusion = 'confusion',
    curiosity = 'curiosity',
    desire = 'desire',
    disappointment = 'disappointment',
    disapproval = 'disapproval',
    disgust = 'disgust',
    embarrassment = 'embarrassment',
    excitement = 'excitement',
    fear = 'fear',
    gratitude = 'gratitude',
    grief = 'grief',
    joy = 'joy',
    love = 'love',
    nervousness = 'nervousness',
    optimism = 'optimism',
    pride = 'pride',
    realization = 'realization',
    relief = 'relief',
    remorse = 'remorse',
    sadness = 'sadness',
    surprise = 'surprise',
}

export const EMOTION_MAPPING: {[emotion in Emotion]?: Emotion} = {
    admiration: Emotion.joy,
    approval: Emotion.amusement,
    caring: Emotion.neutral,
    curiosity: Emotion.neutral,
    disapproval: Emotion.disappointment,
    optimism: Emotion.gratitude,
    realization: Emotion.surprise,
    relief: Emotion.gratitude,
    remorse: Emotion.sadness
}

export const EMOTION_PROMPTS: {[emotion in Emotion]?: string} = {
    neutral: 'calm expression',
    amusement: 'subtle smirk, amused expression',
    anger: 'enraged, angry expression',
    annoyance: 'annoyed, dismayed expression',
    confusion: 'stunned, baffled, confused expression',
    desire: 'sexy, alluring, seductive expression',
    disappointment: 'unhappy, disappointed expression',
    disgust: 'disgusted expression',
    embarrassment: 'embarrassed, blushing, sheepish expression',
    excitement: 'keen, excited expression',
    fear: 'terrified expression',
    gratitude: 'relieved, thankful expression',
    grief: 'depressed, sobbing expression',
    joy: 'happy, smiling',
    love: 'adorable, grinning, blushing, lovestruck expression',
    nervousness: 'nervous, uneasy expression',
    pride: 'proud, haughty, puffed up expression',
    sadness: 'sad, upset expression, teary-eyed',
    surprise: 'shocked, surprised expression',
}


const darkTheme = createTheme({
    palette: {
        mode: 'dark',
        background: {
            default: '#121212',
            paper: '#1e1e1e',
        },
        text: {
            primary: '#ffffff',
            secondary: '#aaaaaa',
        }
    },
});

const CHARACTER_ART_PROMPT: string = 'plain flat background, standing, full body, head-to-toe';
const CHARACTER_NEGATIVE_PROMPT: string = 'border, ((close-up)), scenery, special effects, scene, dynamic angle, action, cut-off';
const BACKGROUND_ART_PROMPT: string = 'unpopulated, visual novel background scenery, background only, scenery only';

const DEFAULT_BORDER_COLOR: string = '#1e1e1edd';
export const DEFAULT_OUTFIT_NAME: string = 'Starter Outfit';

// Replace trigger words with less triggering words, so image gen can succeed.
export function substitute(input: string) {
    const synonyms: [string, string][] = [
        ['old-school', 'retro'],
        ['old school', 'retro'],
        ['oldschool', 'retro'],
        ['schoolgirl', 'college girl'],
        ['school girl', 'college girl'],
        ['schoolboy', 'college guy'],
        ['school boy', 'college guy'],
        ['schoolteacher', 'professor'],
        ['school teacher', 'professor'],
        ['school', 'college'],
        ['youngster', 'individual'],
        ['child', 'individual'],
        ['kid', 'individual'],
        ['young', 'youthful']
    ];

    for (const [key, replacement] of synonyms) {
        const regex = new RegExp(key, 'gi');
        input = input.replace(regex, (match) => {
            return match[0] === match[0].toUpperCase()
                ? replacement.charAt(0).toUpperCase() + replacement.slice(1)
                : replacement;
        });
    }

    return input;
}

export function generateGuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {
        const random = (Math.random() * 16) | 0;
        const value = char === 'x' ? random : (random & 0x3) | 0x8;
        return value.toString(16);
    });
}

type EmotionPack = {[key: string]: string};

export class Expressions extends StageBase<InitStateType, ChatStateType, MessageStateType, ConfigType> {

    // Chat state:
    chatState: ChatStateType;

    // Message state:
    messageState: MessageStateType;

    // Saved to storage
    wardrobes: {[key: string]: WardrobeType} = {};
    // This is used for comparison versus storage wardrobes to determine if storage has changed outside this instance of the stage,
    // so that those changes can be reconciled against a potentially modified wardrobes above.
    // Should be set after a successful load/reconciliation.
    backupWardrobes: {[key: string]: WardrobeType} = {};

    // Not saved:
    emotionPipeline: any = null;
    zeroShotPipeline: any = null;
    depthPipeline: any = null;
    generateCharacters: boolean;
    generateBackgrounds: boolean;
    artStyle: string;
    speakers: {[key: string]: Speaker};
    flagBackground: boolean = false;
    alphaMode: boolean;

    readonly fac = new FastAverageColor();
    readonly colorThief = new ColorThief();
    private messageHandle?: MessageQueueHandle;
    private speakerSettingsHandle?: SpeakerSettingsHandle;

    constructor(data: InitialData<InitStateType, ChatStateType, MessageStateType, ConfigType>) {
        super(data);
        const {
            characters,
            config,
            messageState,
            chatState,
            users
        } = data;

        console.log(config);
        console.log(characters);
        console.log(users);

        this.speakers = {...characters, ...users};

        // Set states or default them.
        this.messageState = {
            backgroundUrl: messageState?.backgroundUrl ?? '',
            depthUrl: messageState?.depthUrl ?? '',
            borderColor: messageState?.borderColor ?? DEFAULT_BORDER_COLOR,
            speakerEmotion: messageState?.speakerEmotion ?? {},
            activeSpeaker: messageState?.activeSpeaker ?? ''
        }

        this.chatState = {
            generatedWardrobes: chatState?.generatedWardrobes ?? {},
            selectedOutfit: chatState?.selectedOutfit ?? {},
            generatedDescriptions: chatState?.generatedDescriptions ?? {},
            speakerVisible: chatState?.speakerVisible ?? {}
        };

        this.generateCharacters = (config?.generateCharacters ?? "True") == "True";
        this.generateBackgrounds = (config?.generateBackgrounds ?? "True") == "True";
        this.alphaMode = (config?.alphaMode ?? "False") == "True";
        this.artStyle = config?.artStyle ?? 'Bold, visual novel style illustration, clean lines';


        if (!this.alphaMode) {
            // Look at characters, set up packs, and initialize values that aren't present in message/chat state
            Object.keys(this.speakers).forEach((charAnonId: string) => {
                const speaker = this.speakers[charAnonId];
                if (!speaker.isRemoved) {
                    if (this.chatState.generatedWardrobes[charAnonId] && this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME] && Object.keys(this.chatState.generatedWardrobes[charAnonId][DEFAULT_OUTFIT_NAME]).length > 0) {
                        console.log('Character has a wardrobe.');
                    } else {
                        console.log('Initializing a new wardrobe.')
                        this.chatState.generatedWardrobes[charAnonId] = {[DEFAULT_OUTFIT_NAME]: {}};
                        this.chatState.selectedOutfit[charAnonId] = DEFAULT_OUTFIT_NAME;
                    }
                }
            });
        }
    }

    async load(): Promise<Partial<LoadResponse<InitStateType, ChatStateType, MessageStateType>>> {
        await this.updateBackground();
        
        try {
            this.emotionPipeline = await Client.connect("ravenok/emotions");
            this.zeroShotPipeline = await Client.connect("ravenok/statosphere-backend");
            this.depthPipeline = await Client.connect("depth-anything/Depth-Anything-V2");
        } catch (except: any) {
            console.error(`Error loading pipelines, error: ${except}`);
            return { success: false, error: except }
        }

        if (this.alphaMode) {
            console.warn('Alpha mode enabled. This is experimental and may break things.');
            // Load wardrobes from storage API:
            this.wardrobes = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
            this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));

            // Load expression pack wardrobes:
            for (let charAnonId of Object.keys(this.speakers)) {
                if ('partial_extensions' in this.speakers[charAnonId]) {
                    const character: Character = this.speakers[charAnonId] as Character;
                    if (character.partial_extensions?.chub?.expressions?.expressions != null) {
                        console.log(`Character ${charAnonId} has an expressions pack.`);
                        // Generate outfit entries for each expressions pack, marked non-generated.
                        for (let expressionPack of Object.values([character.partial_extensions.chub.expressions])) {
                            this.wardrobes[charAnonId].outfits[expressionPack.version] = {
                                images: expressionPack.expressions,
                                name: expressionPack.version,
                                triggerWords: '',
                                generated: false,
                                artPrompt: '',
                            };
                        }
                    }
                }
            }

            // Initialize wardrobes for characters with no loaded wardrobes
            for (let speakerId of Object.keys(this.speakers)) {
                this.wardrobes[speakerId] = this.wardrobes[speakerId] ?? {
                    speakerId: speakerId,
                    outfits: {
                        [generateGuid()]: {
                            name: DEFAULT_OUTFIT_NAME,
                            artPrompt: '',
                            images: {},
                            triggerWords: '',
                            generated: true
                        }
                    }
                } as WardrobeType;
            }
        }

        for (let speaker of Object.values(this.speakers)) {
            if (!(speaker.anonymizedId in this.chatState.speakerVisible)) {
                this.chatState.speakerVisible[speaker.anonymizedId] = !('chatProfile' in speaker);
                //this.singleSpeakerCheck(speaker).then(result => {this.chatState.speakerVisible[speaker.anonymizedId] = result; this.updateChatState()});
            }
        }

        return {
            success: true,
            chatState: this.chatState,
            messageState: this.messageState,
            error: null
        };
    }

    async retrieveWardrobe(speakerId: string): Promise<WardrobeType|null> {
        const wardrobeData = (await this.storage.get('wardrobe').forCharacter(speakerId)).data[0].value;
        console.log(wardrobeData);
        return wardrobeData as WardrobeType || null;
    }

    async updateBackground() {
        await this.messenger.updateEnvironment({background: this.messageState.backgroundUrl});
    }

    async setState(state: MessageStateType): Promise<void> {
        if (state != null) {
            this.messageState = {
                backgroundUrl: state?.backgroundUrl ?? '',
                depthUrl: state?.depthUrl ?? '',
                borderColor: state?.borderColor ?? DEFAULT_BORDER_COLOR,
                speakerEmotion: state?.speakerEmotion ?? {},
                activeSpeaker: state?.activeSpeaker ?? ''
            }
            await this.updateBackground();
        }
    }

    async updateEmotion(speaker: Speaker, content: string) {
        let newEmotion = 'neutral';
        if (this.emotionPipeline != null) {
            try {
                const emotionResult = (await this.emotionPipeline.predict("/predict", {
                    param_0: content,
                }))
                console.log(`Emotion result: `);
                console.log(emotionResult.data[0].confidences);
                newEmotion = emotionResult.data[0].confidences.find((confidence: {label: string, score: number}) => confidence.label != 'neutral' && confidence.score > 0.1)?.label ?? newEmotion;
            } catch (except: any) {
                console.warn(`Error classifying expression, error: ${except}`);
                newEmotion = this.fallbackClassify(content);
            }
        } else {
            newEmotion = this.fallbackClassify(content);
        }
        console.info(`New emotion for ${speaker.name}: ${newEmotion}`);
        this.messageState.speakerEmotion[speaker.anonymizedId] = newEmotion;
        this.messageState.activeSpeaker = speaker.anonymizedId;
        if ((this.alphaMode && !this.wardrobes[speaker.anonymizedId].outfits[this.chatState.selectedOutfit[speaker.anonymizedId]]?.images[EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion]) ||
            (!this.alphaMode && !this.chatState.generatedWardrobes[speaker.anonymizedId][this.chatState.selectedOutfit[speaker.anonymizedId]][EMOTION_MAPPING[newEmotion as Emotion] ?? newEmotion])) {
            this.wrapPromise(
                this.generateSpeakerImage(speaker, this.chatState.selectedOutfit[speaker.anonymizedId], EMOTION_MAPPING[newEmotion as Emotion] ?? (newEmotion as Emotion)),
                `Generating ${newEmotion} for ${speaker.name} (${this.chatState.selectedOutfit[speaker.anonymizedId]}).`);
        }
    }

    async beforePrompt(userMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[userMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[userMessage.anonymizedId], userMessage.content);
        }
        await this.backgroundCheck(userMessage.content);
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    fallbackClassify(text: string): string {
        const lowered = text.toLowerCase();
        let result = 'neutral';
        Object.values(Emotion).forEach(emotion => {
            if(lowered.includes(emotion.toLowerCase())) {
                result = emotion;
            }
        });
        return result;
    }

    async afterResponse(botMessage: Message): Promise<Partial<StageResponse<ChatStateType, MessageStateType>>> {

        if (this.isSpeakerVisible(this.speakers[botMessage.anonymizedId])) {
            await this.updateEmotion(this.speakers[botMessage.anonymizedId], botMessage.content);
        }
        await this.backgroundCheck(botMessage.content);
        if (this.flagBackground) {
            await this.wrapPromise(this.generateBackgroundImage(this.speakers[botMessage.anonymizedId], botMessage.content), 'Generating new background image.');
        }
        return {
            stageDirections: null,
            messageState: this.messageState,
            chatState: this.chatState,
            modifiedMessage: null,
            error: null
        };
    }

    async wrapPromise(promise: Promise<void>|null, message: string): Promise<void> {
        if (!promise) {
            promise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve(void 0);
                }, 3000);
            });
        }
        if (this.messageHandle) {
            this.messageHandle.addLoadingMessage(promise, message);
        }
        return promise;
    }

    stripNonGeneratedOutfits(wardrobe: WardrobeType): WardrobeType {
        return {
            speakerId: wardrobe.speakerId,
            outfits: Object.keys(wardrobe.outfits).reduce((acc: {[key: string]: OutfitType}, outfitKey: string) => {
                if (wardrobe.outfits[outfitKey] && wardrobe.outfits[outfitKey].generated) {
                    acc[outfitKey] = wardrobe.outfits[outfitKey];
                }
                return acc;
            }, {})
        };
    }

    async readCharacterWardrobesFromStorage(speakerIds: string[]): Promise<{[key: string]: WardrobeType}> {
        return this.storage.get('wardrobe').forCharacters(speakerIds.filter(speakerId => this.isSpeakerIdCharacterId(speakerId))).then((data) => {
            console.log('Retrieved wardrobes from storage:');
            console.log(data);
            return data.data.reduce((acc: {[key: string]: WardrobeType}, item) => {
                acc[item.character_id ?? ""] = item.value as WardrobeType;
                return acc;
            }, {});
        });
    }

    async updateChatState() {
        // This function is temporarily doing double duty to set/reconcile wardrobes and update chat state:
        if (this.alphaMode) {

            const remoteWardrobes: {[key: string]: WardrobeType} = await this.readCharacterWardrobesFromStorage(Object.keys(this.speakers));
            // Should check for differences in wardrobes between existingWardrobes and this.backupWardrobes, then apply non-conflicting changes to this.wardrobes before saving.
            // Bear in mind that this.backupWardrobes will have non-generated outfits, while we expect existingWardrobes to have only generated outfits.
            console.log('Existing wardrobes from storage:');
            console.log(remoteWardrobes);
            // Compare existingWardrobes against this.backupWardrobes to find differences in generated outfits:
            Object.keys(remoteWardrobes).forEach((speakerId) => {
                if (this.backupWardrobes[speakerId]) {
                    for (let outfitKey of Object.keys(remoteWardrobes[speakerId].outfits)) {
                        // If the outfit exists in existingWardrobes but not in backup, it means it was added by another user
                        // We need to add it to this.wardrobes.
                        if (!this.backupWardrobes[speakerId].outfits[outfitKey] && Object.keys(remoteWardrobes[speakerId].outfits[outfitKey].images).length > 0) {
                            console.log(`Outfit ${outfitKey} was added for ${speakerId}`);
                            this.wardrobes[speakerId].outfits[outfitKey] = remoteWardrobes[speakerId].outfits[outfitKey];
                        } else if (this.backupWardrobes[speakerId].outfits[outfitKey] && !this.wardrobes[speakerId].outfits[outfitKey]) {
                            // If the outfit exists in backup but not in this.wardrobes, it means it was removed locally.
                            console.log(`Outfit ${outfitKey} was removed for ${speakerId}`);
                            // No action is taken; the deletion will be pushed below.
                        } else {
                            // If the outfit exists in both existingWardrobes and backup, we need to compare images to see if any need to be updated.
                            // Be smart about this; some images may have been updated in this.wardrobes. We only want to apply differences and not all images.
                            console.log(`Outfit ${outfitKey} exists in both existing and backup wardrobes for ${speakerId}. Checking images...`);

                            const existingImages = remoteWardrobes[speakerId].outfits[outfitKey].images || {};
                            const backupImages = this.backupWardrobes[speakerId].outfits[outfitKey].images || {};
                            const currentImages = this.wardrobes[speakerId].outfits[outfitKey].images || {};
                            
                            // Compare each emotion/image key
                            Object.keys(existingImages).forEach((emotionKey) => {
                                const existingImageUrl = existingImages[emotionKey];
                                const backupImageUrl = backupImages[emotionKey];
                                
                                // If the image exists in existing but not in backup, it was added externally
                                if (existingImageUrl && !backupImageUrl) {
                                    console.log(`Image for emotion '${emotionKey}' was added externally for ${speakerId}/${outfitKey}`);
                                    this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                                }
                                // If the image exists in both but has different URLs, it was updated externally
                                else if (existingImageUrl && backupImageUrl && existingImageUrl !== backupImageUrl) {
                                    // Only apply if we haven't locally modified this image since backup
                                    if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImageUrl) {
                                        console.log(`Image for emotion '${emotionKey}' was updated externally for ${speakerId}/${outfitKey}`);
                                        this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey] = existingImageUrl;
                                    } else {
                                        console.log(`Image for emotion '${emotionKey}' has conflicting changes - keeping local version for ${speakerId}/${outfitKey}`);
                                    }
                                }
                            });
                            
                            // Check for images that were removed externally
                            Object.keys(backupImages).forEach((emotionKey) => {
                                if (backupImages[emotionKey] && !existingImages[emotionKey]) {
                                    // Only remove if we haven't locally modified this image since backup
                                    if (!currentImages[emotionKey] || currentImages[emotionKey] === backupImages[emotionKey]) {
                                        console.log(`Image for emotion '${emotionKey}' was removed externally for ${speakerId}/${outfitKey}`);
                                        delete this.wardrobes[speakerId].outfits[outfitKey].images[emotionKey];
                                    } else {
                                        console.log(`Image for emotion '${emotionKey}' was removed externally but has local changes - keeping local version for ${speakerId}/${outfitKey}`);
                                    }
                                }
                            });

                            // Check for outfit name, generatedDescription, and triggerWords:
                            if (remoteWardrobes[speakerId].outfits[outfitKey].name && 
                                this.wardrobes[speakerId].outfits[outfitKey].name !== remoteWardrobes[speakerId].outfits[outfitKey].name && 
                                this.wardrobes[speakerId].outfits[outfitKey].name == this.backupWardrobes[speakerId].outfits[outfitKey].name) {
                                console.log(`Outfit name changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].name}' to '${remoteWardrobes[speakerId].outfits[outfitKey].name}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].name = remoteWardrobes[speakerId].outfits[outfitKey].name;
                            }
                            if (remoteWardrobes[speakerId].outfits[outfitKey].artPrompt && 
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt !== remoteWardrobes[speakerId].outfits[outfitKey].artPrompt &&
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt == this.backupWardrobes[speakerId].outfits[outfitKey].artPrompt) {
                                console.log(`Outfit description changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].artPrompt}' to '${remoteWardrobes[speakerId].outfits[outfitKey].artPrompt}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].artPrompt = remoteWardrobes[speakerId].outfits[outfitKey].artPrompt;
                            }
                            if (remoteWardrobes[speakerId].outfits[outfitKey].triggerWords && 
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords !== remoteWardrobes[speakerId].outfits[outfitKey].triggerWords &&
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords == this.backupWardrobes[speakerId].outfits[outfitKey].triggerWords) {
                                console.log(`Outfit trigger words changed for ${speakerId}/${outfitKey} from '${this.wardrobes[speakerId].outfits[outfitKey].triggerWords}' to '${remoteWardrobes[speakerId].outfits[outfitKey].triggerWords}'`);
                                this.wardrobes[speakerId].outfits[outfitKey].triggerWords = remoteWardrobes[speakerId].outfits[outfitKey].triggerWords;
                            }
                        }
                    }
                    // Compare outfits:
                    Object.keys(this.backupWardrobes[speakerId].outfits).forEach((outfitName) => {
                        if (this.backupWardrobes[speakerId].outfits[outfitName] && !remoteWardrobes[speakerId].outfits[outfitName]) {
                            // If the outfit exists in backup but not in existing, it means it was removed
                            console.log(`Outfit ${outfitName} was removed for ${speakerId}`);
                        }
                    });
                }
            });

            // Push current wardrobes
            console.log('Pushing wardrobe updates to storage.');
            await Promise.all(Object.keys(this.wardrobes).map(async (speakerId) => {
                console.log(`Pushing wardrobe update for ${speakerId}`);
                if (this.wardrobes[speakerId] && this.wardrobes[speakerId].outfits) {
                    if (this.isSpeakerIdCharacterId(speakerId)) {
                        const response = await this.storage.set('wardrobe', this.stripNonGeneratedOutfits(this.wardrobes[speakerId])).forCharacter(speakerId);
                        console.log(response);
                    } else {
                        // Store for user/persona--not sure exactly what this will look like.
                        // this.storage.set('wardrobe', this.wardrobes[speakerId]).forPersona(speakerId);
                    }
                }
            }));

            // With everything reconciled and updated, set backup to a copy of wardrobes.
            console.log('update backupWardrobes');
            this.backupWardrobes = JSON.parse(JSON.stringify(this.wardrobes));
        }

        await this.messenger.updateChatState(this.chatState);
    }

    buildArtPrompt(speaker: Speaker, outfit: string, emotion: Emotion): string {
        let generatedDescription = '';
        if (this.alphaMode) {
            generatedDescription = this.wardrobes[speaker.anonymizedId]?.outfits?.[outfit]?.artPrompt ?? '';
        } else {
            generatedDescription = this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`] ?? '';
        }
        if (generatedDescription) {
            return `(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfit}`]}), ((${CHARACTER_ART_PROMPT})), (${EMOTION_PROMPTS[emotion]})`;
        }
        return `No art prompt yet available for ${speaker.name} (${outfit}). Enter a custom prompt below or leave it blank to have the LLM craft an art prompt from context.`;
    }

    async generateSpeakerImagePrompt(speaker: Speaker, outfitKey: string): Promise<void> {
        // Must first build a visual description for this character:
        console.log(`Generating a physical description of ${speaker.name}.`);
        const outfitName = this.alphaMode ? this.wardrobes[speaker.anonymizedId].outfits[outfitKey].name : outfitKey;
        const imageDescription = await this.generator.textGen({
            prompt:
                `Chat History:\n{{messages}}\n\n` +
                (outfitName != DEFAULT_OUTFIT_NAME ? `New Outfit:\n${outfitName}\n\n` : '') +
                `Information about ${speaker.name}:\n${this.getSpeakerDescription(speaker)}\n\n` +
                `Instruction:\nThe goal of this request is to digest the information about ${speaker.name} and construct a simple, comprehensive, and functional visual description of ${speaker.name}. ` +
                `The chat history may involve other characters, but this system response will fixate on ${speaker.name}, forsaking other characters or background details. ` +
                `The result will be fed directly into an image generator, which is unfamiliar with this character, ` +
                `so use concise tags and keywords to convey all essential visual details about them, ` +
                `presenting ample and exhaustive character appearance notes--particularly if they seem obvious: gender, race, skin tone, hair do/color, physique, body shape, outfit, fashion, setting/theme, style, etc. ` +
                (outfitName != DEFAULT_OUTFIT_NAME ?
                    `Describe and emphasize that ${speaker.name} is wearing this prescribed outfit or vibe: ${outfitName}. Develop authentic visual details for the outfit. Aside from that, ` :
                    `Chat history is provided for potential context on ${speaker.name}'s current look; `) +
                `focus on persistent physical details over fleeting ones as this description will be applied to a variety of situations. Output the final visual description below.\n\n` +

                `Sample Response:\nWoman, tall, youthful, dark flowing hair, dark brown hair, loose wavy hair, tanned skin, muscular, modern clothes, worn jeans, dark red bomber jacket, dark brown eyes, thin lips, red and white running shoes, white tanktop.\n\n` +
                `Sample Response:\nMan in a billowing tattered cloak, Medieval fantasy, sinister appearance, dark hair, middle-aged, hair graying at temples, sallow face, elaborate wooden staff, green gem in staff, dark robes with green highlights.\n\n` +
                `Sample Response:\nA willowy androgynous figure, short spiky hair, pale skin, wearing a sleek black bodysuit with silver accents, futuristic cyberpunk style, glowing blue tattoos on arms, piercing blue eyes.\n\n` +
                '',
            min_tokens: 50,
            max_tokens: 140,
            include_history: true
        });
        if (imageDescription?.result) {
            console.log(`Received an image description: ${imageDescription.result}`);
            this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`] = imageDescription.result;
            if (this.alphaMode && this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].artPrompt = imageDescription.result;
            }
            await this.updateChatState();
        } else {
            return;
        }
    }

    async generateSpeakerImage(speaker: Speaker, outfitKey: string, emotion: Emotion): Promise<void> {
        console.log(`Current generated descriptions: ${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`]} and ${this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]?.artPrompt}`);
        const outfitName = this.alphaMode ? this.wardrobes[speaker.anonymizedId].outfits[outfitKey].name : outfitKey;

        if (!this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`] || (this.alphaMode && !this.wardrobes[speaker.anonymizedId]?.outfits?.[outfitKey]?.artPrompt)) {
            await this.generateSpeakerImagePrompt(speaker, outfitKey);
        }

        // Must do neutral first:
        if (emotion != Emotion.neutral && !this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral]) {
            emotion = Emotion.neutral;
        }
        console.log(`Generating ${emotion} image for ${speaker.name} (${outfitName}).`)
        if (emotion == Emotion.neutral) {
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(this.buildArtPrompt(speaker, outfitKey, emotion)),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            // Clear entire pack then assign this image:
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey] = {};
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral] = imageUrl;
            if (this.alphaMode) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images = {};
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[Emotion.neutral] = imageUrl;
            }
            /*if (!this.generating) {
                this.generateNextImage(0);
            }*/
        } else {
            const imageUrl = (await this.generator.imageToImage({
                image: this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral],
                prompt: substitute(`(Art style: ${this.artStyle}), (${this.chatState.generatedDescriptions[`${speaker.anonymizedId}_${outfitKey}`]}), (${CHARACTER_ART_PROMPT}), ((Strong Emotion: ${EMOTION_PROMPTS[emotion]}))`),
                negative_prompt: CHARACTER_NEGATIVE_PROMPT,
                aspect_ratio: AspectRatio.WIDESCREEN_VERTICAL,
                remove_background: true,
                strength: 0.1
            }))?.url ?? this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][Emotion.neutral] ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a ${emotion} image for ${speaker.name}.`);
            }
            this.chatState.generatedWardrobes[speaker.anonymizedId][outfitKey][emotion] = imageUrl;
            if (this.alphaMode) {
                this.wardrobes[speaker.anonymizedId].outfits[outfitKey].images[emotion] = imageUrl;
            }
        }
        await this.updateChatState();
    }

    async backgroundCheck(content: string): Promise<void> {
        if (this.flagBackground || !this.generateBackgrounds || !content) return;

        if (this.messageState.backgroundUrl) {
            const TRANSITION_LABEL = 'transitions to a new location';
            const STAY_LABEL = 'does not alter the location or setting';
            try {
                const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                        sequence: content,
                        candidate_labels: [STAY_LABEL, TRANSITION_LABEL],
                        hypothesis_template: 'This passage {}.',
                        multi_label: true
                    })});
                const result = JSON.parse(`${response.data[0]}`);
                console.log('Zero-shot result:');
                console.log(result);
                if (result.labels[0] == STAY_LABEL || result.scores[0] < 0.5) {
                    return;
                }
            } catch (except) {
                console.warn(except);
                return;
            }
        }

        this.flagBackground = true;
    }

    async generateBackgroundImage(character: Speaker, content: string): Promise<void> {
        // Must first build a visual description for the background
        this.flagBackground = false
        console.log(`Generate a description of the background.`);
        const imageDescription = await this.generator.textGen({
            prompt:
                ((character && 'personality' in character) ? `Information about ${character.name}, for Flavor:\n${character.personality}` : '') +
                `Chat History:\n{{messages}}\n\n` +
                `Current Instruction:\nThe goal of this task is to digest the flavor text and chat history to construct a comprehensive and concise visual description of the current scenery. ` +
                `This system response will be fed directly into an image generator, which is unfamiliar with the setting; ` +
                `use tags and keywords to convey all essential details about the location, ambiance, weather, or time of day (as applicable), ` +
                `presenting ample appearance notes. Fixate on the visual details of the surroundings, ignoring action or characters.\n\n` +
                `Sample Response:\nDesolate wasteland, sandy, oppressively bright, glare, cracked earth, forlorn crags.\n\n` +
                `Sample Response:\nSmall-town America, charming street, quaint houses, alluring shopfronts, crisp fall foliage.\n\n` +
                `Sample Response:\nCramped sci-fi hallway, dim emergency lighting, aboard a space station, haunting shapes, loose ducts.\n\n` +
                `Sample Response:\nForgotten ruins, mossy worn stonework, dense forest, swampy surroundings, entrance leading deep into the unknown, pervasive mist.`,
            min_tokens: 50,
            max_tokens: 150,
            include_history: true
        });
        if (imageDescription?.result) {
            console.log(`Received an image description: ${imageDescription.result}. Generating a background.`);
            const imageUrl = (await this.generator.makeImage({
                prompt: substitute(`(Art style: ${this.artStyle}), (${BACKGROUND_ART_PROMPT}), (${imageDescription.result})`),
                aspect_ratio: AspectRatio.CINEMATIC_HORIZONTAL,
            }))?.url ?? '';
            if (imageUrl == '') {
                console.warn(`Failed to generate a background image.`);
            } else {
                if (this.alphaMode) {
                    // This endpoint takes actual image data and not a URL; need to load data from imageUrl
                    const response = await fetch(imageUrl);
                    const imageBlob = await response.blob();
                    // Need to get a HtmlImageElement for getPalette:
                    const imageElement = document.createElement('img');
                    imageElement.src = URL.createObjectURL(imageBlob);
                    const colors = this.colorThief.getPalette(imageElement, 10);
                    console.log(`Color palette: ${colors}`);
                    this.messageState.depthUrl = '';
                    try {
                        const depthResponse = await this.depthPipeline.predict("/on_submit", {image: imageBlob});
                        console.log(depthResponse);
                        this.messageState.depthUrl = depthResponse.data[1].url;
                    } catch (err) {
                        console.warn(`Failed to generate depth map for background image: ${err}`);
                    }
                }
            }
            this.messageState.backgroundUrl = imageUrl;
            try {
                this.messageState.borderColor = (await this.fac.getColorAsync(imageUrl)).rgba ?? DEFAULT_BORDER_COLOR;
            } catch(err) {
                this.messageState.borderColor = DEFAULT_BORDER_COLOR;
            }
            await this.updateBackground();
        }
    }


    async singleSpeakerCheck(speaker: Speaker) {
        const SINGLE_CHARACTER_LABEL = `a character named ${speaker.name}`;
        const MULTI_CHARACTER_LABEL = `multiple characters named ${speaker.name}`;
        const NARRATOR_LABEL = 'a narrator, setting, or scenario';
        try {
            const response = await this.zeroShotPipeline.predict("/predict", {data_string: JSON.stringify({
                    sequence: `Name: ${speaker.name}\nDescription: ${this.getSpeakerDescription(speaker)}`,
                    candidate_labels: [SINGLE_CHARACTER_LABEL, MULTI_CHARACTER_LABEL, NARRATOR_LABEL],
                    hypothesis_template: `The focus is {}.`,
                    multi_label: true
                })});
            const result = JSON.parse(`${response.data[0]}`);
            console.log('Zero-shot result:');
            console.log(result);
            if (result.labels && result.labels[0] != SINGLE_CHARACTER_LABEL) {
                console.log(`${speaker.name} determined to be non-solo character.`);
                return false;
            }
        } catch (except) {
            console.warn(except);
        }
        return true;
    }

    isSpeakerIdCharacterId(speakerId: string): boolean {
        return this.isSpeakerCharacter(this.speakers[speakerId]);
    }

    isSpeakerCharacter(speaker: Speaker): boolean {
        return speaker && 'personality' in speaker;
    }

    getSpeakerDescription(speaker: Speaker) {
        return 'personality' in speaker ? speaker.personality : ('chatProfile' in speaker ? speaker.chatProfile : '');
    }

    getSpeakerEmotion(anonymizedId: string): Emotion {
        return this.messageState.speakerEmotion[anonymizedId] as Emotion ?? Emotion.neutral;
    }

    getSpeakerImage(anonymizedId: string, outfit: string, emotion: Emotion, defaultUrl: string): string {
        if (this.alphaMode) {
            return this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[EMOTION_MAPPING[emotion] ?? emotion] ?? this.wardrobes[anonymizedId]?.outfits?.[outfit]?.images?.[Emotion.neutral] ?? defaultUrl;
        }
        return this.chatState.generatedWardrobes[anonymizedId][(outfit && outfit in this.chatState.generatedWardrobes[anonymizedId]) ? outfit : DEFAULT_OUTFIT_NAME][EMOTION_MAPPING[emotion] ?? emotion] ?? this.chatState.generatedWardrobes[anonymizedId][outfit][Emotion.neutral] ?? defaultUrl;
    }

    isSpeakerInUi(speaker: Speaker) {
        return !speaker.isRemoved;
    }
    isSpeakerActive(speaker: Speaker) {
        return speaker.anonymizedId == this.messageState.activeSpeaker
    }
    isSpeakerVisible(speaker: Speaker) {
        // Characters default to true, Users to false
        return this.chatState.speakerVisible[speaker.anonymizedId] ?? ('personality' in speaker);
    }
    isSpeakerDisplayed(speaker: Speaker) {
        return this.isSpeakerActive(speaker) || (this.isSpeakerInUi(speaker) && this.isSpeakerVisible(speaker));
    }

    render(): ReactElement {
        const count = Object.values(this.speakers).filter(speaker => this.isSpeakerDisplayed(speaker)).length;
        let index = 0;

        return(
            <div className="big-stacker"
                key={'big-over-stacker'}
                style={{
                    width: '100vw',
                    height: '100vh',
                    position: 'relative',
                    alignItems: 'stretch',
                    overflow: 'hidden'
                }}
            >
                <ThemeProvider theme={darkTheme}>
                    {this.alphaMode ? (
                        <NewSpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.messageState.borderColor}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${this.wardrobes[char.anonymizedId].outfits[outfit].name}).`);
                            }}
                            />) : (
                        <SpeakerSettings
                            register={(handle) => {this.speakerSettingsHandle = handle;}}
                            stage={this}
                            borderColor={this.messageState.borderColor}
                            onRegenerate={(char, outfit, emotion) => {
                                this.wrapPromise(this.generateSpeakerImage(char, outfit, emotion), `Generating ${emotion} for ${char.name} (${outfit}).`);
                            }}
                        />)
                    }
                    <MessageQueue register={(handle) => {this.messageHandle = handle;}} borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}/>
                    {/* Regenerate buttons for each character */}
                    <div style={{display: "flex", flexDirection: "column", gap: 10, alignItems: "end"}}>
                        {Object.values(this.speakers).filter(c => this.isSpeakerInUi(c)).map((speaker, i) => (
                            <SpeakerButton
                                key={`character_options_${speaker.anonymizedId}`}
                                speaker={speaker}
                                stage={this}
                                borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}
                                onOpenSettings={(sp) => this.speakerSettingsHandle?.setSpeaker(sp)}
                            />
                        ))}
                    </div>
                    <BackgroundImage imageUrl={this.messageState.backgroundUrl} depthUrl={this.messageState.depthUrl} borderColor={this.messageState.borderColor ?? DEFAULT_BORDER_COLOR}/>
                    <AnimatePresence>
                        {Object.values(this.speakers).map(character => {
                            if (this.isSpeakerDisplayed(character)) {
                                index++;
                                let xPosition = count == 1 ? 50 :
                                    ((index % 2 == 1) ?
                                        (Math.ceil(index / 2) * (50 / (Math.ceil(count / 2) + 1))) :
                                        (Math.floor(index / 2) * (50 / (Math.floor(count / 2) + 1)) + 50));
                                // Farther from 50, higher up on the screen:
                                let yPosition = Math.ceil(Math.abs(xPosition - 50) / 5);
                                // Closer to 50, higher visual priority:
                                const zIndex = Math.ceil((50 - Math.abs(xPosition - 50)) / 5);

                                return <SpeakerImage
                                    key={`character_${character.anonymizedId}`}
                                    speaker={character}
                                    emotion={this.getSpeakerEmotion(character.anonymizedId)}
                                    xPosition={xPosition}
                                    yPosition={yPosition}
                                    zIndex={zIndex}
                                    imageUrl={this.getSpeakerImage(character.anonymizedId, this.chatState.selectedOutfit[character.anonymizedId], this.getSpeakerEmotion(character.anonymizedId), '')}
                                    isTalking={this.messageState.activeSpeaker == character.anonymizedId}
                                    alphaMode={this.alphaMode}
                                />
                            } else {
                                return <></>
                            }
                        })}
                    </AnimatePresence>
                </ThemeProvider>
            </div>

        );
    }

}
